<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<title>Club</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="src/styles.css" />
</head>
<body>
<header>
  <h1><a href="clubs.html" style="color:#2563eb;text-decoration:none;font-size:18px;" aria-label="Torna a elenco club">&larr; Club</a></h1>
  <nav aria-label="Principale">
    <a href="index.html">Home</a>
    <a href="listone.html">Listone</a>
    <a href="asta.html">Asta</a>
    <a href="competizioni.html">Competizioni</a>
  </nav>
</header>
<main>
  <div id="clubHeader" aria-live="polite"></div>
  <section class="panel" aria-labelledby="rosterTitle">
    <h2 id="rosterTitle">Rosa Attuale</h2>
    <table class="data-table table-compact contract-table" id="rosterTable" role="table" aria-describedby="rosterHelp">
      <thead><tr role="row">
        <th class="sortable" scope="col" data-sort="name">Giocatore</th>
        <th class="sortable" scope="col" data-sort="roles">Ruoli</th>
        <th class="sortable" scope="col" data-sort="quote">Quota firma</th>
        <th class="sortable" scope="col" data-sort="original">Orig?</th>
        <th class="sortable" scope="col" data-sort="years">Durata</th>
        <th class="sortable" scope="col" data-sort="wage">Stip. annuo</th>
        <th class="sortable" scope="col" data-sort="season0" id="seasonCol1"></th>
        <th class="sortable" scope="col" data-sort="season1" id="seasonCol2"></th>
        <th class="sortable" scope="col" data-sort="season2" id="seasonCol3"></th>
        <th class="sortable" scope="col" data-sort="season3" id="seasonCol4"></th>
  <th scope="col" aria-label="Azioni"></th>
      </tr></thead>
      <tbody></tbody>
    </table>
    <p id="rosterHelp" class="table-note">Clic sulle intestazioni per ordinare. Colonne stagione indicano ingaggio dovuto (50% se svincolato).</p>
    <div class="released-block" id="releasedSection" data-aria-hidden="true" aria-live="polite">
      <h3 style="margin-top:0;">Giocatori Svincolati</h3>
  <table class="data-table table-compact contract-table" id="releasedTable" role="table"><thead><tr><th>Giocatore</th><th>Ruoli</th><th>Stip. attuale</th><th>Scadenza</th><th aria-label="Azioni"></th></tr></thead><tbody></tbody></table>
    </div>
  </section>
  <section class="panel" id="financeSection" aria-labelledby="financeTitle">
    <h2 id="financeTitle">Storico Operazioni Finanziarie <select id="yearFilter" aria-label="Filtra per anno"><option value="">Tutte</option></select></h2>
    <table class="data-table table-compact" id="txTable" role="table"><thead><tr><th>Data</th><th>Descrizione</th><th>Operazione</th><th>Saldo</th></tr></thead><tbody></tbody></table>
  </section>
</main>
<div id="modalRoot" aria-live="assertive"></div>
<script type="module">
import { ensureAuth } from './src/js/auth.js';
import { initData, saveData } from './src/js/storage.js';
import { recalcClubWage, releasePlayer, editContract, deleteRosterEntry, currentSeasonYear, computeClubBudgetFromTransactions, syncAllClubBudgets, addFinancialTransaction, recomputeClubTransactions, normalizeTransactionsSchema } from './src/js/model.js';
import { uiAlert, uiConfirm, openCustomModal, applyWageIntensity, wageCellHTML, announce, escapeHtml } from './src/js/ui.js';
// --- Utility data formatting (mancante prima) ---
function formatItDate(iso){ if(!iso) return ''; const parts = iso.split('-'); if(parts.length!==3) return iso; return parts[2]+'/'+parts[1]+'/'+parts[0]; }
(async () => {
  await ensureAuth();
  let data = await initData();
  normalizeTransactionsSchema(data);
  syncAllClubBudgets(data);
  const params = new URLSearchParams(location.search);
  const clubId = params.get('id');
  const club = data.clubs.find(c=>c.id===clubId);
  if(!club){ document.body.innerHTML='<p>Club non trovato</p>'; return; }
  club.budget = computeClubBudgetFromTransactions(club);
  saveData(data);
  // Ordine ruoli fisso di default (se non fornito esplicitamente nei dati)
  const DEFAULT_ROLE_ORDER = ['POR','DC','B','DD','DS','E','M','C','T','W','A','PC'];
  const roleOrder = (data.rolesOrder && data.rolesOrder.length) ? data.rolesOrder : DEFAULT_ROLE_ORDER;
  const orderIndex = roleOrder.reduce((m,r,i)=>{m[r]=i;return m;},{});
  const sortRoles = roles => roles.slice().sort((a,b)=> (orderIndex[a]??99)-(orderIndex[b]??99));
  const roleClass = r => { if (r==='POR') return 'role-gk'; if (['B','DC','DD','DS'].includes(r)) return 'role-def'; if (['E','M','C'].includes(r)) return 'role-mid'; if (['W','T'].includes(r)) return 'role-wing'; if (['A','PC'].includes(r)) return 'role-att'; return 'role-mid'; };
  const roleBadgesHTML = roles => `<span class='role-badges'>${sortRoles(roles).map(r=>`<span class="role-badge ${roleClass(r)}" aria-label="Ruolo ${r}">${r}</span>`).join('')}</span>`;
  // Restituisce l'indice primario del ruolo (min index secondo orderIndex)
  function rolePrimaryIndex(roles){ if(!roles || !roles.length) return 999; return Math.min(...roles.map(r=> (orderIndex[r]??999))); }
  function seasonHeaders() { const y=currentSeasonYear(); return [y,y+1,y+2,y+3]; }
  const hdrYears = seasonHeaders();
  function formatSeasonLabel(y){ if(!y && y!==0) return ''; const start = Number(y); if(isNaN(start)) return String(y); const endTwo = String(start+1).slice(-2); return `${start}-${endTwo}`; }
  ['seasonCol1','seasonCol2','seasonCol3','seasonCol4'].forEach((id,i)=>{ const el=document.getElementById(id); if(el){ el.textContent = formatSeasonLabel(hdrYears[i]); el.dataset.label = hdrYears[i]; }});
  let rosterSort = { key: 'name', dir: 'asc' };
  initSortableHeaders();
  function inferAuctionPhaseFromDate(isoDate){
    if(!isoDate) return null; const [y,m,d] = isoDate.split('-').map(n=>parseInt(n));
    if(m===1 || (m===2 && d<=10)) return 'invernale';
    if(m===7 || (m===8 && d<=15)) return 'estiva1';
    if(m===8 && d>15 || m===9) return 'estiva2';
    return null;
  }
  function migrateTransactions() {
    if(!club.transactions) return;
    const isLikelyAuctionPurchase = (desc='') => {
      if(!/^Acquisto\s/i.test(desc)) return false; const low = desc.toLowerCase();
      if(low.includes(' da ')) return false;
      if(/\b(scambio|prestito|riscatto|cessione|bonus|budget)\b/i.test(desc)) return false;
      return /^Acquisto\s+[A-Za-zÀ-ÖØ-öø-ÿ' .-]+$/i.test(desc.trim());
    };
    let changed=false;
    club.transactions.forEach(t=>{
      if(!t.id) { t.id = 'tx_'+Math.random().toString(36).slice(2,10); changed=true; }
      if(!t.meta) t.meta={};
      if(!t.meta.type && /^Acquisto\s/i.test(t.description||'')) { t.meta.type='acquisto'; changed=true; }
      if(t.meta.type==='acquisto' && !t.meta.auction && isLikelyAuctionPurchase(t.description||'')) {
        const phase = inferAuctionPhaseFromDate(t.date);
        if(phase){ t.meta.auction = { phase, year: parseInt(t.date.slice(0,4)), inferred:true }; changed=true; }
      }
      if(t.meta?.auction && !isLikelyAuctionPurchase(t.description||'')) { delete t.meta.auction; changed=true; }
      if(t.meta?.auction && t.meta.type!=='acquisto') { delete t.meta.auction; changed=true; }
    });
    if(changed) { recomputeClubTransactions(club); saveData(data); }
  }
  migrateTransactions();
  seedPolentaHistory();
  renderFinance();
  function initSortableHeaders() {
    const ths = document.querySelectorAll('#rosterTable thead th.sortable');
    ths.forEach(th => {
      if(!th.dataset.label) th.dataset.label = th.textContent.trim();
      th.tabIndex=0; th.setAttribute('role','columnheader');
      th.addEventListener('click', () => { const key = th.dataset.sort; if(rosterSort.key === key) { rosterSort.dir = rosterSort.dir==='asc' ? 'desc' : 'asc'; } else { rosterSort.key = key; rosterSort.dir='asc'; } updateHeaderSortIndicators(); renderRoster(); announce('Ordinato per '+th.dataset.label+' '+(rosterSort.dir==='asc'?'crescente':'decrescente')); });
      th.addEventListener('keydown', e=> { if(e.key==='Enter' || e.key===' ') { e.preventDefault(); th.click(); } });
    });
    updateHeaderSortIndicators();
  }
  function updateHeaderSortIndicators() {
    const ths = document.querySelectorAll('#rosterTable thead th.sortable');
    ths.forEach(th => { th.classList.remove('asc','desc'); if(th.dataset.sort === rosterSort.key) th.classList.add(rosterSort.dir); th.setAttribute('aria-sort', th.dataset.sort===rosterSort.key ? (rosterSort.dir==='asc'?'ascending':'descending') : 'none'); });
  }
  function buildHeader() {
    const h = document.getElementById('clubHeader');
    const [c1,c2] = club.colors?.length?club.colors:['#334','#667'];
    const gradient = `linear-gradient(100deg, ${c1}, ${c2})`;
    let logoHtml='';
    if(club.logo){
      if(/^data:/i.test(club.logo)) { logoHtml = `<img src="${club.logo}" alt="Logo ${club.name}" style="max-width:100%;max-height:100%;object-fit:contain;"/>`; }
      else { logoHtml = `<img src="${club.logo}" alt="Logo ${club.name}" style="max-width:100%;max-height:100%;object-fit:contain;" onerror="this.src='media/BBSL_Logo.png'"/>`; }
    } else { logoHtml = `<span aria-hidden="true">${club.name.charAt(0).toUpperCase()}</span>`; }
    const trophies = club.trophies||[];
  const trophyIcons = trophies.map(t=>`<div class='trophy'><svg viewBox='0 0 24 24' aria-hidden='true'><path d='M5 3h14v3h3v4c0 3.31-2.69 6-6 6-.65 0-1.27-.1-1.85-.29L12 19l-2.15-3.29A5.978 5.978 0 0 1 8 16c-3.31 0-6-2.69-6-6V6h3V3Zm2 3v4c0 2.21 1.79 4 4 4s4-1.79 4-4V6H7Z'/></svg><span>${formatSeasonLabel(t.season)||''}</span></div>`).join('');
    const rosterCount = club.roster.filter(r=>r.status==='active').length;
    const rosterPerc = Math.min(100, Math.round(rosterCount/30*100));
    const wagePerc = Math.min(100, Math.round((club.wageTotal||0)/110*100));
    const budgetCls = club.budget>=300?'high': (club.budget>=120?'mid':'low');
    h.innerHTML = `<section class='hero club-hero fade-in' style='background:${gradient};'>`+
      `<div class='club-hero-inner'>`+
        `<div class='club-hero-logo' aria-label='Logo club'>${logoHtml}</div>`+
        `<div class='info' style='flex:1;min-width:240px;'>`+
          `<h1 style='margin:0 0 4px;font-size:40px;'>${club.name} <span class='trophies' aria-label='Trofei'>${trophyIcons}</span></h1>`+
          `<div class='club-hero-meta'>`+
            `<span><strong>Presidente:</strong> ${club.president||'-'}</span>`+
            `<span><strong>Fondazione:</strong> ${club.founded||'-'}</span>`+
            `<span><strong>Stadio:</strong> ${club.stadium||'-'}</span>`+
            `<span><strong>Città:</strong> ${club.city||'-'}</span>`+
          `</div>`+
          `<div class='club-hero-metrics'>`+
            `<div class='metric-block'><strong>Rosa</strong><div class='mini-progress'><span style='width:${rosterPerc}%;'></span></div><div style='margin-top:4px;'>${rosterCount}/30</div></div>`+
            `<div class='metric-block'><strong>Ingaggi</strong><div class='mini-progress wage'><span style='width:${wagePerc}%;'></span></div><div style='margin-top:4px;'>${club.wageTotal}/110</div></div>`+
            `<div class='metric-block'><strong>Budget</strong><div style='margin-top:2px;'><span class='badge-budget ${budgetCls}'>${club.budget}</span></div></div>`+
          `</div>`+
        `</div>`+
        `<div style='display:flex;flex-direction:column;gap:8px;align-items:flex-end;'>`+
          `<button class='btn-outline btn-sm' id='editClubBtn' aria-label='Modifica dati club'>Modifica Club</button>`+
        `</div>`+
      `</div>`+
    `</section>`;
    document.getElementById('editClubBtn').addEventListener('click', openEditClubModal);
  }
  function wageForSeason(entry, year) {
    if(entry.status==='active' && year>=entry.startSeason && year<=entry.endSeason) return entry.wage;
    if(entry.status==='released' && entry.releaseStartSeason && year>=entry.releaseStartSeason && year<=entry.endSeason) return Math.round(entry.wage*0.5);
    return '';
  }
  function formatWageDisplay(val) {
    if(val===null || val===undefined || val==='') return '';
    const rounded = Math.round(Number(val)*1000)/1000; return rounded.toFixed(3).replace(/\.0+$/,'').replace(/\.(\d*?)0+$/,'.$1');
  }

  // Format per tabella svincolati: tronca (no rounding) a 3 decimali e rimuove zeri finali
  function formatWageTrunc(val){
    if(val===null || val===undefined || val==='') return '';
    const n = Number(val);
    if(isNaN(n)) return '';
    const truncated = Math.trunc(n * 1000) / 1000; // tronca, non arrotonda
    let s = truncated.toFixed(3);
    s = s.replace(/\.0+$/,'');
    s = s.replace(/\.(\d*?)0+$/,'.$1');
    return s;
  }
  function renderRoster() {
    recalcClubWage(club, data); buildHeader();
    const tbody = document.querySelector('#rosterTable tbody');
    if(!tbody) return; tbody.innerHTML='';
    const rows = club.roster.filter(r=>r.status==='active').map(r=>({ r, p: data.players.find(pl=>pl.id===r.playerId) })).filter(x=>x.p);
    rows.sort((a,b)=> rosterComparator(a,b));
    rows.forEach(({r,p}) => {
      const tr = document.createElement('tr');
      const badge = r.original?`<span class='badge-original tooltip' aria-label='Giocatore originale'><span>ORIG</span><span class='tooltip-content'>Originale</span></span>`:`<span class='badge-duplicate tooltip' aria-label='Giocatore duplicato'><span>DUP</span><span class='tooltip-content'>Duplicato</span></span>`;
      tr.innerHTML = `<td>${p.name}</td><td>${roleBadgesHTML(p.roles)}</td><td>${r.originalQuote}</td><td>${badge}</td><td>${r.contractYears}</td><td class='wage-cell'>${wageCellHTML(r.wage)}</td>`+
        `${hdrYears.map(y=>`<td class='wage-cell'>${wageCellHTML(wageForSeason(r,y))}</td>`).join('')}`+
        `<td class='actions'>`+
          `<button class='icon-btn btn-sm' data-edit='${r.playerId}' aria-label='Modifica contratto ${p.name}'>✏️</button>`+
          `<button class='icon-btn btn-sm' data-release='${r.playerId}' aria-label='Svincola ${p.name}'>Svincola</button>`+
          `<button class='icon-btn btn-sm danger' data-delete='${r.playerId}' aria-label='Elimina ${p.name}'>❌</button>`+
        `</td>`;
      tbody.appendChild(tr);
    });
    const rel = club.roster.filter(r=>r.status==='released');
    const relRoot = document.getElementById('releasedSection');
    if(relRoot){
      if(rel.length) {
        relRoot.dataset.ariaHidden='false';
        const rtbody=document.querySelector('#releasedTable tbody'); if(rtbody) { rtbody.innerHTML=''; }
        rel.forEach(r=>{
          const p=data.players.find(pl=>pl.id===r.playerId); if(!p) return;
          const halfVal = Number(r.wage) * 0.5;
          const halfLabel = formatWageTrunc(halfVal);
          if(rtbody) rtbody.innerHTML += `<tr><td>${p.name}</td><td>${roleBadgesHTML(p.roles)}</td><td class='wage-cell'><span class='wage-intensity' data-val='${Number.isFinite(halfVal)?halfVal:0}' data-cap='110'>${escapeHtml(halfLabel)}</span></td><td>${formatSeasonLabel(r.endSeason)}</td><td><button class='icon-btn btn-sm danger' data-delete='${r.playerId}' aria-label='Rimuovi record svincolo ${p.name}'>❌</button></td></tr>`;
        });
        if(rtbody) applyWageIntensity(rtbody);
      } else { relRoot.dataset.ariaHidden='true'; }
    }
    applyWageIntensity(tbody);
  }
  function rosterComparator(a,b) {
    const dir = rosterSort.dir === 'asc' ? 1 : -1; function num(v){ return typeof v==='number' ? v : (v===''? -Infinity : Number(v)); }
    const key = rosterSort.key; const seasonsMap = { season0:0, season1:1, season2:2, season3:3 }; let va,vb;
    switch(key) {
      case 'name': va=a.p.name.toLowerCase(); vb=b.p.name.toLowerCase(); return va.localeCompare(vb)*dir;
      case 'roles': {
        const ai = rolePrimaryIndex(a.p.roles), bi = rolePrimaryIndex(b.p.roles);
        if(ai !== bi) return (ai - bi) * dir;
        va = sortRoles(a.p.roles).join(','); vb = sortRoles(b.p.roles).join(','); return va.localeCompare(vb) * dir;
      }
      case 'quote': va=a.r.originalQuote; vb=b.r.originalQuote; return (va-vb)*dir;
      case 'original': va=a.r.original?1:0; vb=b.r.original?1:0; return (vb-va)*dir;
      case 'years': va=a.r.contractYears; vb=b.r.contractYears; return (va-vb)*dir;
      case 'wage': va=a.r.wage; vb=b.r.wage; return (va-vb)*dir;
      default:
        if(key in seasonsMap) { const idx=seasonsMap[key]; const y=hdrYears[idx]; va=wageForSeason(a.r,y)||''; vb=wageForSeason(b.r,y)||''; return (num(va)-num(vb))*dir; }
    }
    return 0;
  }
  document.getElementById('rosterTable').addEventListener('click', async e => {
    const pid = e.target.dataset.release || e.target.dataset.edit || e.target.dataset.delete; if(!pid) return;
    if(e.target.dataset.release) { const season = currentSeasonYear(); try { releasePlayer(data, club.id, pid, season); saveData(data); renderRoster(); announce('Giocatore svincolato'); } catch(err){ uiAlert(err.message); } }
    else if(e.target.dataset.edit) { openEditContractModal(pid); }
    else if(e.target.dataset.delete) { if(await uiConfirm('Eliminare dalla rosa?')) { deleteRosterEntry(data, club.id, pid); saveData(data); renderRoster(); announce('Giocatore eliminato dalla rosa'); } }
  });
  document.getElementById('releasedSection').addEventListener('click', async e => { const pid = e.target.dataset.delete; if(!pid) return; if(await uiConfirm('Eliminare definitivamente?')) { deleteRosterEntry(data, club.id, pid); saveData(data); renderRoster(); announce('Record svincolo eliminato'); } });
  function openEditClubModal() {
    const palette = ['#003366','#004c99','#0077b6','#0f766e','#15803d','#a21caf','#be123c','#c48c00','#111827','#6d28d9','#dc2626','#2563eb','#16a34a','#64748b'];
    let sel = [...(club.colors||[])];
    const body = `<form id='editClubForm' class='form-vertical' style='display:flex;flex-direction:column;gap:8px;'>
      <label>Nome <input name='name' value='${escapeHtml(club.name)}' required></label>
      <label>Presidente <input name='president' value='${escapeHtml(club.president||'')}'></label>
      <label>Fondazione <input name='founded' value='${escapeHtml(club.founded||'')}'></label>
      <label>Stadio <input name='stadium' value='${escapeHtml(club.stadium||'')}'></label>
      <label>Città <input name='city' value='${escapeHtml(club.city||'')}'></label>
      <label>Percorso Logo Statico <input name='logoPath' placeholder='media/nomefile.webp' value='${/^data:/i.test(club.logo)?'':escapeHtml(club.logo||'')}'></label>
      <small class='text-muted' style='font-size:11px;'>Inserisci path relativo (media/). I dataURL legacy verranno rimossi.</small>
      <div><strong style='font-size:12px;'>Colori</strong><div id='colorGrid' class='color-picker-grid' style='margin-top:4px;'></div></div>
    </form>`;
    const { modalEl, whenClosed } = openCustomModal({ title:'Modifica Club', bodyHTML: body, actions:[{ key:'cancel', label:'Annulla', variant:'btn-outline', cancel:true }, { key:'save', label:'Salva' }] });
    const grid = modalEl.querySelector('#colorGrid');
    const paletteRender = () => { grid.innerHTML=''; palette.forEach(col => { const div=document.createElement('div'); div.className='color-swatch'+(sel.includes(col)?' selected':''); div.style.background=col; div.tabIndex=0; div.setAttribute('role','button'); div.addEventListener('click', ()=>{ if(sel.includes(col)) sel=sel.filter(c=>c!==col); else if(sel.length<2) sel.push(col); else sel[1]=col; paletteRender(); }); div.addEventListener('keydown',e=>{ if(['Enter',' '].includes(e.key)){ e.preventDefault(); div.click(); }}); grid.appendChild(div); }); };
    paletteRender();
    whenClosed.then(res => {
      if(res.action!=='save') return;
      const fd = res.formData;
      club.name = fd.get('name').trim();
      club.president = fd.get('president').trim();
      club.founded = fd.get('founded').trim();
      club.stadium = fd.get('stadium').trim();
      club.city = fd.get('city').trim();
      if(sel.length) club.colors = sel;
      const logoPath = (fd.get('logoPath')||'').trim();
      if(logoPath) club.logo = logoPath; else if(!/^data:/i.test(club.logo)) club.logo='';
      saveData(data);
      renderRoster(); announce('Club aggiornato');
    });
  }
  function openEditContractModal(playerId) {
    const entry = club.roster.find(r=>r.playerId===playerId); if(!entry) return; const player = data.players.find(p=>p.id===playerId); if(!player) return;
    const body = `<form id='editContractForm' style='display:flex;flex-direction:column;gap:8px;'>
      <label>Quota firma <input name='quote' type='number' value='${entry.originalQuote}' required></label>
      <label>Durata (1-4) <input name='years' type='number' min='1' max='4' value='${entry.contractYears}' required></label>
      <label>Stagione inizio <input name='startSeason' type='number' value='${entry.startSeason}' required></label>
    </form>`;
    openCustomModal({ title:`Contratto - ${escapeHtml(player.name)}`, bodyHTML: body, actions:[{ key:'cancel', label:'Annulla', variant:'btn-outline', cancel:true }, { key:'save', label:'Salva' }] }).whenClosed.then(res => {
      if(res.action!=='save') return; const fd = res.formData; try { editContract(data, club.id, playerId, fd.get('quote'), fd.get('startSeason'), fd.get('years')); saveData(data); renderRoster(); announce('Contratto aggiornato'); } catch(err){ uiAlert(err.message); }});
  }
  function seedPolentaHistory() {
  // Non creare più automaticamente una transazione seed "Saldo iniziale".
  // Prima veniva inserita quando non c'erano transazioni, ma questo produceva
  // saldi duplicati/contraddittori alla successiva importazione CSV.
  club.transactions = club.transactions || [];
  return;
  }
  function renderFinance() {
    const yearSel = document.getElementById('yearFilter');
    if (!yearSel) return;
  const yearsAlready = new Set(Array.from(yearSel.options).map(o=>o.value));
  // Ordina le transazioni dalla più recente alla più vecchia per visualizzazione
  // Escludi transazioni di seed (saldo iniziale) dalla visualizzazione
  const txs = (club.transactions||[]).filter(t=> !t.meta?.seed).slice().sort((a,b)=> a.date === b.date ? 0 : (a.date < b.date ? 1 : -1));
    txs.forEach(t=> { if(t.date) { const y=t.date.slice(0,4); if(y && !yearsAlready.has(y)) { const opt=document.createElement('option'); opt.value=y; opt.textContent=y; yearSel.appendChild(opt); yearsAlready.add(y); } } });
    if(!document.getElementById('addTxBtn')) {
      const h2 = document.getElementById('financeTitle');
      const btn = document.createElement('button'); btn.id='addTxBtn'; btn.className='btn-sm'; btn.type='button'; btn.style.marginLeft='8px'; btn.textContent='Nuova Operazione'; btn.addEventListener('click', () => openEditTransactionModal()); h2.appendChild(btn);
    }
    if(!document.getElementById('astaGroupsBtn')) {
      const h2 = document.getElementById('financeTitle');
      const btn2 = document.createElement('button'); btn2.id='astaGroupsBtn'; btn2.className='btn-outline btn-sm'; btn2.type='button'; btn2.style.marginLeft='6px'; btn2.textContent='Gruppi Asta'; btn2.addEventListener('click', ()=> openAstaGroupModal()); h2.appendChild(btn2);
    }
    if(!document.getElementById('importHistBtn')) {
      const h2 = document.getElementById('financeTitle');
      const btn3 = document.createElement('button'); btn3.id='importHistBtn'; btn3.className='btn-outline btn-sm'; btn3.type='button'; btn3.style.marginLeft='6px'; btn3.textContent='Import Storico'; btn3.addEventListener('click', ()=> openImportHistoricalModal()); h2.appendChild(btn3);
    }
    if(!document.getElementById('clearAllBtn')){
      const h2 = document.getElementById('financeTitle');
      const btnClear = document.createElement('button'); btnClear.id='clearAllBtn'; btnClear.className='btn-outline danger btn-sm'; btnClear.type='button'; btnClear.style.marginLeft='6px'; btnClear.textContent='Elimina tutto';
      btnClear.addEventListener('click', async ()=> { await clearAllTransactions(); });
      h2.appendChild(btnClear);
    }
  const filterYear = yearSel.value;
    const tbody = document.querySelector('#txTable tbody');
    if(!tbody) return;
    tbody.innerHTML='';
    let filtered = txs;
  if(filterYear) filtered = filtered.filter(t=> t.date && t.date.startsWith(filterYear));
    if(!filtered.length) {
      tbody.innerHTML = `<tr><td colspan='4' style='text-align:center;font-size:12px;color:#666;'>Nessuna operazione${filterYear? ' per '+filterYear:''}</td></tr>`;
      return;
    }
  filtered.forEach(t => {
      const tr = document.createElement('tr');
      tr.dataset.txId = t.id;
  const opStr = `${t.sign==='-'?'-':'+'} ${formatMoney(t.amount)}`;
  tr.innerHTML = `<td>${formatItDate(t.date)}</td><td>${escapeHtml(t.description||'')}</td><td>${opStr}</td><td>${formatMoney(t.after)}</td>`;
      tr.tabIndex=0; tr.setAttribute('role','row');
      tr.addEventListener('click', ()=> openEditTransactionModal(t.id));
      tr.addEventListener('keydown', e=> { if(e.key==='Enter' || e.key===' ') { e.preventDefault(); openEditTransactionModal(t.id); }});
      tbody.appendChild(tr);
    });
  }
  function deleteTransaction(txId) {
    const idx = (club.transactions||[]).findIndex(t=>t.id===txId);
    if(idx===-1) return false;
    club.transactions.splice(idx,1);
    recomputeClubTransactions(club);
    saveData(data);
    renderFinance();
    announce('Operazione eliminata');
    return true;
  }

  // Cancella tutte le transazioni del club con conferma e backup in localStorage
  async function clearAllTransactions(){
    if(!club.transactions || !club.transactions.length){ uiAlert('Nessuna operazione da eliminare'); return; }
    const confirmed = await uiConfirm('Eliminare TUTTE le operazioni finanziarie del club? Questa operazione non è reversibile. Procedere?');
    if(!confirmed) return;
    try{
      const key = `backup_alltx_club_${club.id}_` + Date.now();
      localStorage.setItem(key, JSON.stringify(club.transactions));
    } catch(e){ /* ignore storage errors */ }
    club.transactions = [];
    recomputeClubTransactions(club);
    saveData(data);
    renderFinance(); renderRoster(); announce('Storico operazioni cancellato');
  }
  function openEditTransactionModal(txId){
    const editing = txId ? (club.transactions||[]).find(t=>t.id===txId) : null;
    const body = `<form id='txForm' style='display:flex;flex-direction:column;gap:8px;'>
      <label>Data <input name='date' type='date' value='${editing?editing.date:new Date().toISOString().slice(0,10)}' required></label>
      <label>Descrizione <input name='description' value='${editing?escapeHtml(editing.description):''}' required></label>
      <label>Segno <select name='sign'><option value='+' ${!editing || editing.sign==='+'?'selected':''}>+</option><option value='-' ${editing && editing.sign==='-'?'selected':''}>-</option></select></label>
      <label>Importo <input name='amount' type='number' step='0.01' value='${editing?editing.amount:''}' required></label>
    </form>`;
    const actions = [];
    if(editing) actions.push({ key:'delete', label:'Elimina', variant:'btn-outline danger' });
    actions.push({ key:'cancel', label:'Annulla', variant:'btn-outline', cancel:true });
    actions.push({ key:'save', label:'Salva' });
    openCustomModal({ title: `${editing?'Modifica':'Nuova'} Operazione`, bodyHTML: body, actions }).whenClosed.then(async res => {
      if(res.action==='cancel') return;
      if(res.action==='delete' && editing) {
        if(await uiConfirm('Eliminare operazione?')) { deleteTransaction(editing.id); renderFinance(); renderRoster(); }
        return;
      }
      if(res.action==='save') {
        const fd = res.formData;
        const date = fd.get('date');
        const description = (fd.get('description')||'').trim();
        const sign = fd.get('sign');
        const amount = Number(fd.get('amount'));
        if(!description){ uiAlert('Descrizione obbligatoria'); return; }
        if(isNaN(amount)||amount<=0){ uiAlert('Importo > 0'); return; }
        if(editing){
          // Simula la modifica su una copia per verificare il saldo risultante
          try {
            const txsCopy = (club.transactions||[]).map(t=> ({ ...t }));
            const idx = txsCopy.findIndex(t=>t.id===editing.id);
            if(idx===-1) throw new Error('Transazione non trovata');
            txsCopy[idx].date = date; txsCopy[idx].description = description; txsCopy[idx].sign = sign; txsCopy[idx].amount = amount;
            // Ricalcola su copia
            recomputeClubTransactions(txsCopy); // note: recomputeClubTransactions expects a club object, but can operate on array structure; we will call a local variant
          } catch(e) {
            // fallback: compute predicted balance by doing a simple simulation
          }
          // Proper simulation: build a temporary object to pass to recomputeClubTransactions
          const tmpClub = { transactions: (club.transactions||[]).map(t=> ({ ...t })) };
          const idx2 = tmpClub.transactions.findIndex(t=>t.id===editing.id);
          if(idx2!==-1){ tmpClub.transactions[idx2].date = date; tmpClub.transactions[idx2].description = description; tmpClub.transactions[idx2].sign = sign; tmpClub.transactions[idx2].amount = amount; }
          recomputeClubTransactions(tmpClub);
          const predicted = tmpClub.transactions && tmpClub.transactions.length ? tmpClub.transactions[tmpClub.transactions.length-1].after : 0;
          const doUpdate = async () => {
            editing.date=date; editing.description=description; editing.sign=sign; editing.amount=amount;
            recomputeClubTransactions(club); saveData(data); announce('Operazione aggiornata');
          };
          if(predicted < 0){
            if(await uiConfirm('La modifica porta il saldo del club sotto zero. Procedere con l\'aggiornamento?')){
              await doUpdate();
            } else {
              announce('Modifica annullata');
            }
          } else {
            await doUpdate();
          }
        } else {
          // Calcola il nuovo saldo previsto e, se scende sotto zero, chiedi conferma all'utente
          const prevBal = (typeof club.budget === 'number') ? club.budget : computeClubBudgetFromTransactions(club);
          const delta = sign === '+' ? amount : -amount;
          const afterBal = prevBal + delta;
          const maybeSave = async () => {
            addFinancialTransaction(data, club.id, { description, sign, amount });
            announce('Operazione aggiunta');
            renderFinance(); renderRoster();
          };
          if(afterBal < 0){
            // Non blocchiamo: chiediamo conferma esplicita e poi salviamo
            if(await uiConfirm('Questa operazione porta il saldo sotto zero. Procedere?')) {
              await maybeSave();
            } else {
              announce('Operazione annullata');
            }
          } else {
            await maybeSave();
          }
          // Evitiamo il doppio render/announce qui (render/announce già chiamati dentro maybeSave)
          return;
        }
        renderFinance(); renderRoster();
      }
    });
  }
  // --- Storico: importazione bulk ---
  function simpleIdHash(str){ let h=0; for(let i=0;i<str.length;i++){ h=(h*31 + str.charCodeAt(i))>>>0; } return h.toString(36); }
  async function ensureXlsxLib(){
    if(window.XLSX) return;
    await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'; s.onload=()=>res(); s.onerror=()=>rej(new Error('Impossibile caricare libreria XLSX')); document.head.appendChild(s); });
  }
  function convertAnyDateToISO(val){
    if(!val) return '';
    if(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(val)) return val; // already ISO
    if(/^[0-9]{2}\/[0-9]{2}\/[0-9]{4}$/.test(val)){ const [d,m,y]=val.split('/'); return `${y}-${m}-${d}`; }
    return val; // fallback
  }
  function parseOperazioneExpr(expr){
  if(!expr) return null;
  // Normalizziamo spazi e separatori decimali (supporto sia "," che ".")
  const clean = (''+expr).replace(/\s+/g,'').replace(/,/g,'.');
  // Accettiamo numeri con decimali: prev +/- delta (es: 600-598, 2+10, 12.50-5.25)
  const m = clean.match(/^([0-9]+(?:\.[0-9]+)?)([+-])([0-9]+(?:\.[0-9]+)?)$/);
  if(!m) return null;
  const prev = Number(m[1]); const sign = m[2]; const val = Number(m[3]);
  return { prev, sign, raw: Math.round(val*100)/100 };
  }
  function formatMoney(v){
    const n = Number(v)||0;
    const fixed = n.toFixed(2);
    if(/\.00$/.test(fixed)) return String(Math.round(n));
    return fixed.replace(/(\.\d*?)0+$/,'$1');
  }
  function xlsxFileToCSV(file){
    return ensureXlsxLib().then(()=> new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload = e => { try { const data = new Uint8Array(e.target.result); const wb = XLSX.read(data,{type:'array'}); const sheetName = wb.SheetNames[0]; const ws = wb.Sheets[sheetName]; const json = XLSX.utils.sheet_to_json(ws,{defval:''});
        const rows = json.map(r=>{ const lower={}; Object.keys(r).forEach(k=> lower[k.toLowerCase()] = r[k]);
          let date = lower.date || lower.data || ''; date = convertAnyDateToISO(date);
          let description = lower.description || lower.descrizione || '';
            let sign = (lower.sign || lower.segno || '').toString();
            let amount = lower.amount || lower.importo || '';
          // Se formato Operazione presente (prev±amount) e mancano sign/amount normali
          if(!sign && !amount && lower.operazione){ const parsed = parseOperazioneExpr(lower.operazione); if(parsed){ sign = parsed.sign; amount = parsed.raw; } }
          return { date, description, sign, amount };
        });
        const header = 'date,description,sign,amount';
        const csvRows = rows.map(r=> [r.date, r.description, r.sign, r.amount].map(v=> (v||'').toString().replace(/"/g,'""')).join(','));
        resolve(header+'\n'+csvRows.join('\n')); } catch(err){ reject(err); } };
      fr.onerror = () => reject(new Error('Lettura file fallita'));
      fr.readAsArrayBuffer(file);
    }));
  }
  // Splitter CSV/TSV robusto con gestione di virgolette
  function splitDelimitedLine(line, delim){
    const out=[]; let cur=''; let inQuotes=false; for(let i=0;i<line.length;i++){ const ch=line[i];
      if(ch==='"') { if(inQuotes && line[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; } continue; }
      if(!inQuotes && ch===delim){ out.push(cur); cur=''; continue; }
      cur+=ch;
    }
    out.push(cur);
    return out;
  }
  function parseHistoricalRaw(raw){
    const errors=[]; const warnings=[]; let rows=[];
    if(!raw || !raw.trim()) { errors.push('Nessun dato'); return { rows:[], errors, warnings }; }
    if(raw.trim().startsWith('[')) {
      try { const arr = JSON.parse(raw); if(!Array.isArray(arr)) { errors.push('JSON non è un array'); } else { rows = arr; } } catch(e){ errors.push('JSON non valido'); }
    } else { // CSV
      const lines = raw.split(/\r?\n/).map(l=> l.replace(/[\uFEFF\u200B]/g,'')).filter(l=>l.trim());
      if(!lines.length){ errors.push('CSV vuoto'); return { rows:[], errors, warnings }; }
      let delim = ','; if(lines[0].split(',').length < 2 && lines[0].includes(';')) delim=';'; else if(lines[0].split(',').length<2 && lines[0].includes('\t')) delim='\t';
      const headerParts = splitDelimitedLine(lines[0], delim).map(h=>h.replace(/^[\uFEFF]/,'').trim().toLowerCase());
      console.log('[ImportStorico] Header rilevato:', headerParts, 'delim:', JSON.stringify(delim));
      const header = headerParts;
      const idx = (name)=> header.indexOf(name);
      const di = idx('date')!==-1?idx('date'):idx('data');
      const descI = idx('description')!==-1?idx('description'):idx('descrizione');
      let signI= idx('sign'); if(signI===-1) signI = idx('segno');
      let amountI = idx('amount'); if(amountI===-1) amountI = idx('importo');
      const opI = idx('operazione');
      const saldoI = idx('saldo');
      if(di===-1||descI===-1){ errors.push('Mancano colonne data/descrizione'); return { rows:[], errors, warnings }; }
      const needsOpParse = opI!==-1 && (signI===-1 || amountI===-1);
      // Heuristica: formato italiano Data;Descrizione;;Operazione;Saldo dove la colonna "sign" contiene in realtà l'espressione prev±amount e la colonna "amount" contiene il saldo finale
      let opInSignExpr=false;
      if(!needsOpParse && opI===-1 && signI!==-1 && amountI!==-1){
        let exprCount=0; let checked=0; for(let i=1;i<Math.min(lines.length,8);i++){ const partsTest = splitDelimitedLine(lines[i], delim); if(partsTest.length<=signI) continue; const cand = (partsTest[signI]||'').trim(); if(!cand) continue; checked++;
          // Rileviamo anche decimali con punto o virgola
          if(/^[0-9]+(?:[.,][0-9]+)?\s*[+-]\s*[0-9]+(?:[.,][0-9]+)?$/.test(cand)) exprCount++; }
        if(checked && exprCount && exprCount/checked >= 0.5) { opInSignExpr=true; console.log('[ImportStorico] Rilevato formato Operazione in colonna sign e saldo in colonna amount'); }
      }
      for(let i=1;i<lines.length;i++){
        const parts = splitDelimitedLine(lines[i], delim);
        if(i<=3) console.log('[ImportStorico] Line', i, parts);
        if(parts.length < Math.max(di, descI, signI, amountI, opI, saldoI)+1){ warnings.push(`Riga ${i}: colonne insufficienti (trovate ${parts.length})`); }
        if(!parts.length) continue;
        let date = (parts[di]||'').trim(); date = convertAnyDateToISO(date);
        let description = (parts[descI]||'').trim();
        let sign = signI!==-1 ? (parts[signI]||'').trim() : '';
        let amountTxt = amountI!==-1 ? (parts[amountI]||'').trim() : '';
        let prevParsed = null;
        if(needsOpParse){ const opExpr = (parts[opI]||'').trim(); const parsed = parseOperazioneExpr(opExpr); if(parsed){
            sign = parsed.sign;
            const amount = parsed.raw; amountTxt = amount.toString(); prevParsed = parsed.prev;
          } else { if(opExpr) { errors.push(`Riga ${i}: operazione non valida (${opExpr})`); } continue; } }
        else if(opInSignExpr){
          // In questo formato la colonna 'sign' contiene in realtà l'espressione prev±delta;
          // manteniamo insieme descrizione, date e la coppia sign+amount così come sono nella stessa riga.
          const expr = sign; const parsed = parseOperazioneExpr(expr);
          if(parsed){ sign = parsed.sign; amountTxt = parsed.raw.toString(); prevParsed = parsed.prev; }
          else { errors.push(`Riga ${i}: espressione operazione non valida (${expr})`); continue; }
          // Nota: se è presente una colonna 'saldo' usiamola come saldo di controllo; non sovrascriviamo il delta con il saldo.
        }
  const saldoAfterTxt = saldoI!==-1 ? (parts[saldoI]||'').trim() : '';
        rows.push({ date, description, sign, amount: amountTxt, prevParsed, saldoAfterTxt, __line:i });
      }
    }
    return { rows, errors, warnings };
  }
  function normalizeHistoricalRows(rawRows){
    const cleaned=[]; const errors=[]; const warnings=[];
    rawRows.forEach((r,idx)=>{
      const line = r.__line || idx+1;
      const date = (r.date||'').trim(); const description=(r.description||'').trim(); const sign=(r.sign||'').trim(); let amountRaw = (r.amount!==undefined?r.amount:'').toString().trim();
      if(!date||!/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(date)) { errors.push(`Riga ${line}: data mancante o invalida`); return; }
      if(!description){ errors.push(`Riga ${line}: descrizione mancante`); return; }
      if(sign!=='+' && sign!=='-'){ errors.push(`Riga ${line}: sign deve essere + o -`); return; }
      amountRaw = amountRaw.replace(',', '.');
      const amount = Number(amountRaw);
      if(!amount || amount<=0){ errors.push(`Riga ${line}: amount non valido`); return; }
      cleaned.push({ date, description, sign, amount: Math.round(amount*100)/100, prevParsed: r.prevParsed, order: idx });
    });
    // Mantieni ordine originale (nessun sort alfabetico che alteri sequenza stessa data)
    // Detect if there are chronological inversions (a date > next date). If so,
    // reorder rows in chronological ascending order (oldest -> newest) to
    // ensure sequential computation is correct. We keep stable ordering for same dates.
    let inversions = 0;
    for(let i=0;i<cleaned.length-1;i++){
      if(cleaned[i].date > cleaned[i+1].date) inversions++;
    }
    if(inversions>0){
      warnings.push(`Rilevate ${inversions} righe fuori ordine cronologico: verranno riordinate`);
      cleaned.sort((a,b)=> a.date===b.date ? a.order - b.order : (a.date<b.date?-1:1));
    } else {
      cleaned.sort((a,b)=> a.date===b.date ? a.order - b.order : (a.date<b.date?-1:1));
    }
    return { cleaned, errors, warnings };
  }
  function buildHistoricalTransactions(cleaned, { startingBalance=undefined, existingIds=new Set(), honorPrevParsed=false }={}){
    // Se startingBalance non fornito, default a 0
    if(startingBalance===undefined) startingBalance = 0;
    let balance = startingBalance; const txs=[]; let newCount=0; let duplicate=0;
    cleaned.forEach(r=>{
      // Per evitare riallineamenti inattesi usiamo solo startingBalance a meno che honorPrevParsed sia true
      if(honorPrevParsed && r.prevParsed!=null && r.prevParsed!==balance){ balance = r.prevParsed; }
      const prev = balance; const delta = r.sign==='-'? -r.amount : r.amount; const after = prev + delta; balance = after;
      const id = 'tx_'+simpleIdHash(`${r.date}|${r.description}|${r.sign}|${r.amount.toFixed(2)}`);
      if(existingIds.has(id)) { duplicate++; return; }
      const tx = { id, date:r.date, description:r.description, prev, sign:r.sign, amount:r.amount, delta, after, meta:{} };
      txs.push(tx); newCount++;
    });
    return { txs, finalBalance: balance, newCount, duplicate, startingBalance };
  }
  function openImportHistoricalModal(){
    const body = `<form id='histImportForm' style='display:flex;flex-direction:column;gap:8px;'>
      <p style='margin:0;font-size:12px;'>Incolla dati (Excel/CSV) formato colonne: Data;Descrizione;...;Operazione;Saldo oppure schema date,description,sign,amount.</p>
      <textarea name='raw' id='histRaw' style='min-height:160px;font-family:monospace;' required></textarea>
      <div style='display:flex;flex-direction:column;gap:4px;'>
        <label style='font-size:12px;'>Carica file (.xlsx/.xls/..csv)
          <input type='file' id='histFile' accept='.xlsx,.xls,.csv' style='margin-top:4px;'>
        </label>
      </div>
      <small style='font-size:11px;color:#555;'>Operazione es: 600-598 (prev - spesa) oppure 2+10 (prev + ricavo). Il Saldo finale viene ricalcolato; quello nel file serve solo per controllo.</small>
    </form>`;
    openCustomModal({ title:'Import Storico', bodyHTML: body, actions:[{ key:'cancel', label:'Annulla', variant:'btn-outline', cancel:true }, { key:'analyze', label:'Analizza' }] }).whenClosed.then(res => {
      if(res.action!=='analyze') return;
      const raw = res.formData.get('raw');
      if(!raw || !raw.trim()) { uiAlert('Textarea vuota: incolla o carica file prima di Analizza'); return; }
      const pr = parseHistoricalRaw(raw);
      if(pr.errors.length){ uiAlert('Errori parsing: '+pr.errors.slice(0,3).join('; ')); return; }
      const norm = normalizeHistoricalRows(pr.rows);
      if(norm.errors.length){ uiAlert('Errori: '+norm.errors.slice(0,5).join(' | ')); return; }
      const existingIds = new Set((club.transactions||[]).map(t=>t.id));
    // startingBalance: per l'analisi del file partiamo sempre da 0 (richiesta UX).
    // Se l'utente sceglie di MERGIARE invece di SOVRASCRIVERE, ricalcoleremo
    // le transazioni importate a partire dal saldo corrente del club.
    // Prepare detailed preview
    let analysisStartingBalance = 0; // sempre 0 per mostrare il file come 'storico pulito'
    const build = buildHistoricalTransactions(norm.cleaned, { startingBalance: analysisStartingBalance, existingIds });
    // CSV ids
    const csvIds = new Set(norm.cleaned.map(r=> 'tx_'+simpleIdHash(`${r.date}|${r.description}|${r.sign}|${r.amount.toFixed(2)}`)));
    // transazioni presenti in app ma non nel CSV
    const appTx = (club.transactions||[]).map(t=> ({ id:t.id, date:t.date, description:t.description, sign:t.sign, amount: Number(t.amount), prev:t.prev, after:t.after }));
    const inAppNotCsv = appTx.filter(t => !csvIds.has(t.id));
    // Predizione merge: ricomputiamo esistenti e costruisci merge build
    recomputeClubTransactions(club);
    const existingLastAfter = (club.transactions && club.transactions.length) ? club.transactions[club.transactions.length-1].after : 0;
    const mergeBuild = buildHistoricalTransactions(norm.cleaned, { startingBalance: existingLastAfter, existingIds });

    // Build preview HTML (tabella limitata a 200 righe per performance)
    const rowsToHtml = (arr, max=200) => {
      if(!arr || !arr.length) return '<p style="font-size:12px;color:#444;">Nessuna</p>';
      const sample = arr.slice(0,max);
      return `<table style='width:100%;border-collapse:collapse;font-size:12px;'><thead><tr><th style='text-align:left;border-bottom:1px solid #ddd;padding:4px;'>Data</th><th style='text-align:left;border-bottom:1px solid #ddd;padding:4px;'>Descrizione</th><th style='text-align:right;border-bottom:1px solid #ddd;padding:4px;'>Op</th><th style='text-align:right;border-bottom:1px solid #ddd;padding:4px;'>Prev</th><th style='text-align:right;border-bottom:1px solid #ddd;padding:4px;'>After</th></tr></thead><tbody>`+
        sample.map(t=>`<tr><td style='padding:4px;'>${escapeHtml(t.date||'')}</td><td style='padding:4px;'>${escapeHtml((t.description||'')).slice(0,80)}</td><td style='padding:4px;text-align:right;'>${t.sign||''}${t.amount!==undefined?t.amount:''}</td><td style='padding:4px;text-align:right;'>${t.prev!==undefined?t.prev:''}</td><td style='padding:4px;text-align:right;'>${t.after!==undefined?t.after:''}</td></tr>`).join('')+
        `</tbody></table>` + (arr.length>max?`<p style='font-size:11px;color:#666;'>Mostrate ${max} di ${arr.length} righe</p>`:'');
    };

    const detailed = `<div style='max-height:60vh;overflow:auto;font-size:13px;line-height:1.3;'>
      <p style='margin:0 0 8px 0;'>Righe CSV valide: <strong>${norm.cleaned.length}</strong></p>
      <p style='margin:0 0 8px 0;'>Nuove (preview overwrite, start 0): <strong>${build.newCount}</strong> - Duplicate ignorate: <strong>${build.duplicate}</strong> - Saldo finale previsto: <strong>${build.finalBalance}</strong></p>
      <div style='margin-bottom:8px;'><strong>Anteprima righe (overwrite)</strong>${rowsToHtml(build.txs)}</div>
      <p style='margin:0 0 8px 0;'>Preview merge (start dal saldo corrente del club: <strong>${existingLastAfter}</strong>): nuove da aggiungere: <strong>${mergeBuild.newCount}</strong> - duplicate ignorate: <strong>${mergeBuild.duplicate}</strong> - Saldo finale previsto: <strong>${mergeBuild.finalBalance}</strong></p>
      <div style='margin-bottom:8px;'><strong>Anteprima righe (merge)</strong>${rowsToHtml(mergeBuild.txs)}</div>
      <p style='margin:0 0 8px 0;'>Transazioni presenti in APP ma NON nel CSV: <strong>${inAppNotCsv.length}</strong></p>
      <div style='margin-bottom:8px;'>${rowsToHtml(inAppNotCsv)}</div>
      <p style='font-size:11px;color:#555;margin-top:8px;'>Scegli <strong>Overwrite</strong> per sostituire interamente lo storico con il contenuto del CSV (backup automatico). Scegli <strong>Merge</strong> per aggiungere solo le righe nuove deduplicate dagli id.</p>
    </div>`;

    // Preview modal: azioni overwrite / merge / cancel
    openCustomModal({ title:'Anteprima Import Dettagliata', bodyHTML: detailed, actions:[{ key:'cancel', label:'Annulla', variant:'btn-outline', cancel:true }, { key:'merge', label:'Merge (Aggiungi nuove)' }, { key:'overwrite', label:'Overwrite (Sovrascrivi)' }] }).whenClosed.then(res2 => {
      if(res2.action!=='merge' && res2.action!=='overwrite') return;
      (async () => {
        const doBackup = () => { try{ localStorage.setItem(`backup_club_${club.id}_`+Date.now(), JSON.stringify(club.transactions||[])); }catch(e){} };
        if(res2.action==='overwrite'){
          if(!build.newCount && !confirm('Il CSV non contiene transazioni nuove rispetto all\'app. Procedere comunque con overwrite?')){ uiAlert('Import annullato'); return; }
          // conferma saldo negativo
          if(build.finalBalance < 0){ if(!await uiConfirm('L\'import sovrascriverà lo storico e porterà il saldo finale sotto zero. Procedere?')){ uiAlert('Import annullato'); return; } }
          doBackup();
          // applica overwrite
          let bal = 0; build.txs.forEach(t=>{ t.prev = bal; t.delta = t.sign==='-'? -t.amount : t.amount; t.after = t.prev + t.delta; bal = t.after; });
          club.transactions = build.txs;
        } else {
          // merge
          recomputeClubTransactions(club);
          const existingLast = (club.transactions && club.transactions.length) ? club.transactions[club.transactions.length-1].after : 0;
          const mergeB = buildHistoricalTransactions(norm.cleaned, { startingBalance: existingLast, existingIds });
          if(!mergeB.newCount){ uiAlert('Nessuna nuova transazione da aggiungere'); return; }
          if(mergeB.finalBalance < 0){ if(!await uiConfirm('L\'import aggiungerà operazioni che porteranno il saldo finale sotto zero. Procedere?')){ uiAlert('Import annullato'); return; } }
          // append
          club.transactions = (club.transactions||[]).concat(mergeB.txs);
        }
        recomputeClubTransactions(club);
        saveData(data);
        renderFinance(); announce('Storico importato');
      })();
    });
    });
    // Setup file handler
    setTimeout(()=>{ const fileInput = document.getElementById('histFile'); const ta = document.getElementById('histRaw'); if(!fileInput||!ta) return; fileInput.addEventListener('change', async ()=> {
      const f = fileInput.files[0]; if(!f) return; try {
        if(/\.xlsx$/i.test(f.name) || /\.xls$/i.test(f.name)) { ta.value = 'Caricamento XLSX...'; const csv = await xlsxFileToCSV(f); ta.value = csv; announce('File Excel convertito'); }
        else if(/\.csv$/i.test(f.name)) { const fr=new FileReader(); fr.onload=e=> { ta.value = e.target.result; announce('CSV caricato'); }; fr.readAsText(f); }
        else { uiAlert('Formato non supportato'); }
      } catch(err){ uiAlert('Errore lettura Excel: '+err.message); ta.value=''; }
    }); },50);
  }
  function openAstaGroupModal(groupKey) {
    const groups = {};
    (club.transactions||[]).forEach(t=> { if(t.meta && t.meta.auction) { const k = t.meta.auction.phase || 'sconosciuta'; groups[k] = groups[k]||[]; groups[k].push(t); }});
    const keys = Object.keys(groups);
    if(!keys.length) { uiAlert('Nessun gruppo asta rilevato'); return; }
    const root = document.getElementById('modalRoot');
    let body = '';
    keys.forEach(k => {
      const list = groups[k].sort((a,b)=> a.date<b.date? -1:1).map(t=> `<li>${formatItDate(t.date)}: ${escapeHtml(t.description||'')} <strong>${t.sign==='-'?'-':'+'}${t.amount}</strong></li>`).join('');
      body += `<details ${groupKey===k?'open':''}><summary style='cursor:pointer;'>Fase ${escapeHtml(k)} (${list.split('<li>').length-1})</summary><ul style='margin:4px 0 10px 18px;font-size:12px;'>${list}</ul></details>`;
    });
    root.innerHTML = `<div class='modal-overlay'><div class='modal' role='dialog' aria-modal='true'>
      <h3>Gruppi Asta</h3>
      <div style='max-height:60vh;overflow:auto;'>${body}</div>
      <div class='modal-actions'>
        <button class='btn-sm' id='closeGroups'>Chiudi</button>
      </div>
    </div></div>`;
    document.getElementById('closeGroups').addEventListener('click', ()=> root.innerHTML='');
  }
  document.getElementById('yearFilter').addEventListener('change', ()=> { renderFinance(); announce('Filtro anno aggiornato'); });
  renderRoster();
})();
</script>
</body>
</html>
