<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<title>Asta</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="src/styles.css" />
<!-- Inline styles removed; all moved into styles.css -->
</head>
<body>
<header>
  <h1>Asta</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="listone.html">Listone</a>
    <a href="clubs.html">Club</a>
    <a href="competizioni.html">Competizioni</a>
  </nav>
</header>
<main>
  <section class="hero fade-in" style="margin-top:0;">
    <h1 style="margin:0 0 8px;">Sessione Asta</h1>
    <p class="subtitle">Gestione live degli acquisti per la divisione selezionata. Filtra tra fasi e anni di asta e assegna acquisti aggiornando automaticamente budget e ingaggi.</p>
    <div id="divisionSwitch" class="toolbar" style="margin-top:16px;"></div>
    <div class="toolbar" style="margin-top:4px;">
      <label style="font-size:13px;">Fase: <select id="auctionPhase" class="btn-sm" style="margin:0 0 0 6px; padding:6px 10px;"><option value="estiva1">Asta estiva 1</option><option value="estiva2">Asta estiva 2</option><option value="invernale">Asta invernale</option></select></label>
      <label style="font-size:13px;">Anno: <input type="number" id="auctionYear" class="w-90" style="margin-left:6px; padding:6px 10px;"></label>
      <span id="auctionSessionDisplay" class="pill pill-primary" style="margin-left:8px;">-</span>
    </div>
  </section>
  <section class="panel">
    <h2 style="margin-top:0;">Nuovo Acquisto</h2>
    <form id="assignForm">
      <select name="clubId" id="clubSelect" required><option value="">Club</option></select>
      <div style="position:relative;">
        <input id="playerSearch" placeholder="Cerca giocatore libero" autocomplete="off" class="w-220" />
        <div id="playerSuggestions" class="suggestions" style="width:280px;"></div>
      </div>
      <input name="price" type="number" min="0" placeholder="Prezzo" class="w-110" required />
      <button class="btn-sm">Compra</button>
    </form>
    <small style="display:block;margin-top:6px;">Contratto sempre annuale. Stipendio calcolato al 25% della quotazione attuale.</small>
  </section>
  <section id="auctionBoards" class="h-scroll" aria-label="Board acquisti club"></section>
  <section id="sandboxSection" class="panel" style="margin-top:18px;">
    <h2>La mia asta (Sandbox privata)</h2>
    <div class="toolbar" style="align-items:flex-end;">
      <label>Identificativo personale: <input id="sandboxUserId" placeholder="es. nick" class="w-110"></label>
      <label>Club ufficiale: <select id="sbClubSelect" class="w-110"><option value="">--</option></select></label>
      <button id="sandboxSetUserBtn" class="btn-sm">Imposta / Carica</button>
      <button id="sandboxExportBtn" class="btn-sm" disabled>Esporta</button>
      <label style="display:inline-flex; align-items:center; gap:4px;">Importa <input type="file" id="sandboxImportInput" style="display:none;" accept="application/json"><button id="sandboxImportBtn" class="btn-sm" disabled>File</button></label>
      <button id="sandboxResetBtn" class="btn-sm btn-outline" disabled>Reset</button>
      <span id="sandboxStatus" style="font-size:12px;color:#555;"></span>
    </div>
    <div id="sandboxContent" style="display:none;">
      <details open>
        <summary style="cursor:pointer;font-weight:600;">Formazione tipo</summary>
        <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:20px;">
          <div style="flex:1 1 320px; min-width:300px;">
            <div id="sbClubInfo" class="sb-club-info" style="display:none;"></div>
            <div style="margin-top:8px;">
              <label style="font-size:12px;">Modulo rapido: <select id="sbModuleSelect" style="font-size:12px;"></select></label>
            </div>
            <div id="sbField"></div>
            <small>Click su slot per assegnare / modificare. Ogni slot = 1 titolare + 2 riserve. Cambio modulo non cancella i giocatori se i ruoli restano compatibili.</small>
          </div>
          <div style="flex:1 1 320px; min-width:300px;">
            <h3>Simulazione Rosa</h3>
            <div id="sbRosterSummary" style="font-size:11px; margin:4px 0 6px; font-weight:600;">-</div>
            <table class="data-table table-compact" aria-label="Rosa Sandbox">
              <thead><tr><th style="text-align:left;">Giocatore</th><th>Ruoli</th><th>Stip.</th><th>Anni (SB)</th><th>Az.</th></tr></thead>
              <tbody id="sbRosterBody"></tbody>
            </table>
          </div>
        </div>
      </details>
      <details style="margin-top:16px;" open>
        <summary style="cursor:pointer;font-weight:600;">Appunti aste</summary>
        <div id="appuntiLegend" class="sb-appunti-legend">
          <span><span class="inline-color" style="background:#86efac;border-color:#65a30d;"></span>In mia rosa</span>
          <span><span class="inline-color" style="background:#fde68a;border-color:#d97706;"></span>Originale altra divisione</span>
            <span><span class="inline-color" style="background:#fecaca;border-color:#dc2626;"></span>Altra rosa stessa divisione</span>
        </div>
        <div style="margin:10px 0;">
          <button id="sbCreateAppuntiBtn" class="btn-sm">Crea appunti</button>
        </div>
        <div id="sbAppuntiContainer" style="display:flex; flex-direction:column; gap:20px;"></div>
      </details>
    </div>
  </section>
</main>
<script type="module">
import { ensureAuth } from './src/js/auth.js';
import { initData, saveData } from './src/js/storage.js';
import { signPlayerToClub, addFinancialTransaction, syncAllClubBudgets, currentSeasonYear, normalizeTransactionsSchema, recomputeClubTransactions, recalcClubWage } from './src/js/model.js';
import { loadSandbox, saveSandbox, resetSandbox, exportSandbox, importSandbox, getCurrentSandboxUserId, setCurrentSandboxUserId } from './src/js/sandbox.js';
import { uiAlert, uiConfirm, uiPrompt, wageCellHTML, applyWageIntensity, announce } from './src/js/ui.js';
(async () => {
  await ensureAuth();
  let data = await initData();
  normalizeTransactionsSchema(data);
  data.meta = data.meta || {};
  data.meta.currentAuction = data.meta.currentAuction || { year: currentSeasonYear(), phase: 'estiva1' };
  syncAllClubBudgets(data);
  const phaseSelect = document.getElementById('auctionPhase');
  const yearInput = document.getElementById('auctionYear');
  const sessionDisplay = document.getElementById('auctionSessionDisplay');
  const phaseLabels = { estiva1: 'Asta estiva 1', estiva2: 'Asta estiva 2', invernale: 'Asta invernale' };
  function refreshAuctionSessionUI(){ phaseSelect.value = data.meta.currentAuction.phase; yearInput.value = data.meta.currentAuction.year; sessionDisplay.textContent = phaseLabels[data.meta.currentAuction.phase] + ' ' + data.meta.currentAuction.year; }
  phaseSelect.addEventListener('change', () => { data.meta.currentAuction.phase = phaseSelect.value; saveData(data); refreshAuctionSessionUI(); renderBoards(); announce('Fase asta cambiata'); });
  yearInput.addEventListener('change', () => { data.meta.currentAuction.year = Number(yearInput.value)||currentSeasonYear(); saveData(data); refreshAuctionSessionUI(); renderBoards(); announce('Anno asta aggiornato'); });
  refreshAuctionSessionUI();

  const divisions = data.divisions || [];
  let currentDivisionId = divisions[0]?.id;
  const divSwitch = document.getElementById('divisionSwitch');
  divisions.forEach(d => { const b = document.createElement('button'); b.textContent=d.name; b.className='switch-btn'+(d.id===currentDivisionId?' active':''); b.type='button'; b.addEventListener('click',()=>{ if(currentDivisionId===d.id) return; currentDivisionId=d.id; document.querySelectorAll('#divisionSwitch .switch-btn').forEach(x=>x.classList.remove('active')); b.classList.add('active'); refreshClubSelect(); renderBoards(); refreshSuggestions(); announce('Divisione cambiata'); }); divSwitch.appendChild(b); });

  const orderIndex = (data.rolesOrder||[]).reduce((m,r,i)=>{m[r]=i;return m;},{});
  const sortRoles = roles => roles.slice().sort((a,b)=> (orderIndex[a]??99)-(orderIndex[b]??99));
  const roleClass = r => { if (r==='POR') return 'role-gk'; if (['B','DC','DD','DS'].includes(r)) return 'role-def'; if (['E','M','C'].includes(r)) return 'role-mid'; if (['W','T'].includes(r)) return 'role-wing'; if (['A','PC'].includes(r)) return 'role-att'; return 'role-mid'; };
  const roleBadgesHTML = roles => `<span class='role-badges'>${sortRoles(roles).map(r=>`<span class=\"role-badge ${roleClass(r)}\">${r}</span>`).join('')}</span>`;
  function playerAssignedInDivision(playerId, divisionId){ return data.clubs.some(c=>c.divisionId===divisionId && c.roster.some(r=>r.playerId===playerId && r.status==='active')); }
  function playerOriginalInOtherDivision(playerId, divisionId){ if(playerAssignedInDivision(playerId, divisionId)) return false; for(const c of data.clubs){ if(c.divisionId===divisionId) continue; if(c.roster.some(r=>r.playerId===playerId && r.status==='active' && r.original)) return true; } return false; }

  const clubSelect = document.getElementById('clubSelect');
  function refreshClubSelect(){ clubSelect.innerHTML='<option value="">Club</option>'; data.clubs.filter(c=>c.divisionId===currentDivisionId).forEach(c=>{ const o=document.createElement('option'); o.value=c.id; o.textContent = `${c.name} (Bdg ${c.budget})`; clubSelect.appendChild(o); }); }
  refreshClubSelect();

  const playerInput = document.getElementById('playerSearch');
  const suggestions = document.getElementById('playerSuggestions');
  let chosenPlayer = null;
  function refreshSuggestions(){ const term = playerInput.value.toLowerCase(); suggestions.innerHTML=''; if(!term) return; data.players.filter(p=> p.name.toLowerCase().includes(term) && !playerAssignedInDivision(p.id, currentDivisionId)).slice(0,15).forEach(p=>{ const warn = playerOriginalInOtherDivision(p.id, currentDivisionId); const div=document.createElement('div'); div.innerHTML = `${p.name} ${roleBadgesHTML(p.roles)} q:${p.quote} ${warn?'<span class=\'badge-original\'>ORIG alt.</span>':''}`; div.addEventListener('click',()=>{ chosenPlayer=p; playerInput.value=p.name; suggestions.innerHTML=''; announce('Selezionato '+p.name); }); suggestions.appendChild(div); }); }
  playerInput.addEventListener('input', ()=>{ chosenPlayer=null; refreshSuggestions(); });
  document.addEventListener('click', e=>{ if(!suggestions.contains(e.target) && e.target!==playerInput) suggestions.innerHTML=''; });

  document.getElementById('assignForm').addEventListener('submit', async e => {
    e.preventDefault(); if(!chosenPlayer){ return uiAlert('Seleziona un giocatore dai suggerimenti'); }
    const fd = new FormData(e.target); const clubId = fd.get('clubId'); const price = Number(fd.get('price'))||0;
    if(!clubId){ return uiAlert('Seleziona un club'); }
    const club = data.clubs.find(c=>c.id===clubId); if(!club || club.divisionId!==currentDivisionId){ return uiAlert('Club non valido per divisione'); }
    if(price<0){ return uiAlert('Prezzo non valido'); }
    if(club.budget < price){ return uiAlert('Budget insufficiente'); }
    try { signPlayerToClub(data, clubId, chosenPlayer.id, 1, chosenPlayer.quote); const clubRoster = data.clubs.find(c=>c.id===clubId)?.roster||[]; const entry = clubRoster.slice().reverse().find(r=>r.playerId===chosenPlayer.id); if(entry) entry.purchasePrice = price; const { year, phase } = data.meta.currentAuction; addFinancialTransaction(data, clubId, { description:`Acquisto ${chosenPlayer.name}`, sign:'-', amount:price, meta:{ type:'acquisto', playerId: chosenPlayer.id, divisionId: currentDivisionId, auction:{ year, phase } } }); saveData(data); e.target.reset(); chosenPlayer=null; refreshClubSelect(); renderBoards(); if(sandbox) renderAppunti(); announce('Acquisto registrato'); } catch(err){ uiAlert(err.message); }
  });

  const boards = document.getElementById('auctionBoards');
  let auctionSort = { key:'order', dir:'asc' };
  function setSort(key){ if(auctionSort.key===key){ auctionSort.dir = auctionSort.dir==='asc'?'desc':'asc'; } else { auctionSort.key=key; auctionSort.dir='asc'; } renderBoards(); announce('Ordinamento aggiornato'); }
  function applySortIndicators(root){ root.querySelectorAll('th.sortable').forEach(th=>{ th.classList.remove('asc','desc'); if(th.dataset.sort===auctionSort.key) th.classList.add(auctionSort.dir); }); }
  function buildOrderMap(club){ const { phase, year } = data.meta.currentAuction; const txs = (club.transactions||[]).filter(t=> t.meta?.type==='acquisto' && t.meta?.auction && t.meta.auction.phase===phase && String(t.meta.auction.year)===String(year)); const orderMap=new Map(); txs.forEach((t,i)=>{ if(t.meta?.playerId) orderMap.set(t.meta.playerId, i+1); }); return orderMap; }
  function rosterComparator(a,b, orderMap){ const dir = auctionSort.dir==='asc'?1:-1; switch(auctionSort.key){ case 'order':{ const oa=orderMap.get(a.r.playerId)||9999; const ob=orderMap.get(b.r.playerId)||9999; if(oa!==ob) return (oa-ob)*dir; return a.p.name.localeCompare(b.p.name)*dir; } case 'name': return a.p.name.localeCompare(b.p.name)*dir; case 'roles': return a.p.roles.join(',').localeCompare(b.p.roles.join(','))*dir; case 'price': return ((a.r.purchasePrice??Infinity)-(b.r.purchasePrice??Infinity))*dir; case 'wage': return (a.r.wage - b.r.wage)*dir; } return 0; }
  function removeAcquisition(club, playerId){ const { phase, year } = data.meta.currentAuction; if(Array.isArray(club.transactions)){ const idx = club.transactions.findIndex(t=> t.meta?.type==='acquisto' && t.meta?.auction?.phase===phase && String(t.meta.auction.year)===String(year) && t.meta?.playerId===playerId); if(idx!==-1) club.transactions.splice(idx,1); } const rIdx = club.roster.findIndex(r=> r.playerId===playerId && r.status==='active'); if(rIdx!==-1) club.roster.splice(rIdx,1); recalcClubWage(club, data); recomputeClubTransactions(club); saveData(data); if(sandbox) renderAppunti(); }
  function renderBoards(){ boards.innerHTML=''; const { phase, year } = data.meta.currentAuction; data.clubs.filter(c=>c.divisionId===currentDivisionId).forEach(c=>{ const div=document.createElement('div'); div.className='club-board'; const [c1,c2] = c.colors || ['#1e293b','#f1f5f9']; const rosterCount = c.roster.filter(r=>r.status==='active').length; const rosterPerc = Math.min(100, Math.round(rosterCount/30*100)); const wagePerc = Math.min(100, Math.round((c.wageTotal||0)/110*100)); const budgetCls = c.budget>=300?'high':(c.budget>=120?'mid':'low'); div.innerHTML = `<div class='board-head' style='background:${c1};color:${c2};'>`+
    `<strong style='font-size:13px;'>${c.name}</strong>`+
    `<div class='board-head-meta'><span>${rosterCount}/30 rosa | ${c.wageTotal}/110 ingaggi</span><span>Budget: <span class='badge-budget ${budgetCls}'>${c.budget}</span></span></div>`+
    `<div class='board-progress'><div><div class='mini-progress'><span style='width:${rosterPerc}%'></span></div><div style='font-size:9px;margin-top:2px;'>Rosa</div></div><div><div class='mini-progress wage'><span style='width:${wagePerc}%'></span></div><div style='font-size:9px;margin-top:2px;'>Ingaggi</div></div></div>`+
    `</div>`; const table=document.createElement('table'); table.className='data-table table-compact'; table.innerHTML = `<thead><tr><th class='sortable' data-sort='order'>#</th><th class='sortable' data-sort='name'>Giocatore</th><th class='sortable' data-sort='roles'>Ruoli</th><th class='sortable' data-sort='price'>Prezzo</th><th class='sortable' data-sort='wage'>Stip.</th><th>Az.</th></tr></thead>`; const tb=document.createElement('tbody'); const orderMap = buildOrderMap(c); const rows = c.roster.filter(r=>r.status==='active').map(r=>({ r, p:data.players.find(pl=>pl.id===r.playerId) })).filter(x=>x.p); rows.sort((a,b)=> rosterComparator(a,b, orderMap)); rows.forEach(({r,p})=>{ const prezzo = (typeof r.purchasePrice==='number')? r.purchasePrice : '-'; const orderNum = orderMap.get(r.playerId) || ''; const canDelete = !!orderMap.get(r.playerId); const delBtn = canDelete ? `<button class='delete-btn' data-del='${c.id}|${r.playerId}' title='Annulla'>✖</button>`:''; const tr=document.createElement('tr'); tr.innerHTML = `<td>${orderNum}</td><td style='text-align:left;'>${p.name}</td><td>${roleBadgesHTML(p.roles)}</td><td>${prezzo}</td><td class='wage-cell'>${wageCellHTML(r.wage)}</td><td>${delBtn}</td>`; tb.appendChild(tr); }); table.appendChild(tb); table.querySelectorAll('th.sortable').forEach(th=> th.addEventListener('click',()=> setSort(th.dataset.sort))); div.appendChild(table); boards.appendChild(div); applyWageIntensity(div); }); }
  boards.addEventListener('click', async e => { const del=e.target.dataset.del; if(!del) return; const [clubId, playerId] = del.split('|'); const club = data.clubs.find(c=>c.id===clubId); const player = data.players.find(p=>p.id===playerId); if(!club||!player) return; if(!(await uiConfirm(`Rimuovere acquisto di ${player.name}?`))) return; removeAcquisition(club, playerId); refreshClubSelect(); renderBoards(); if(sandbox) renderAppunti(); announce('Acquisto rimosso'); });
  renderBoards();

  /* ==== SANDBOX UPGRADED COMPONENTS ==== */
  const MODULES = {
    // Linee dall'alto verso il basso: ogni sotto-array = slot con ruoli accettati
    "4-4-2":   [[['POR']],[['DD'],['DC'],['DC'],['DS']],[['E','W'],['M','C'],['C'],['E']],[['A','PC'],['A','PC']]],
    "4-1-4-1": [[['POR']],[['DD'],['DC'],['DC'],['DS']],[['C','T']],[['E','W'],['M'],['C'],['W']],[['A','PC']]],
    "4-4-1-1": [[['POR']],[['DD'],['DC'],['DC'],['DS']],[['E','W'],['M'],['C'],['E','W']],[['T','A']],[['A','PC']]],
    "4-2-3-1": [[['POR']],[['DD'],['DC'],['DC'],['DS']],[['M'],['M','C']],[['W','T'],['T'],['A']],[['A','PC']]],
    "3-5-2":   [[['POR']],[['DC'],['DC'],['DC','B']],[['E','W'],['M','C'],['M'],['C'],['E']],[['A','PC'],['A','PC']]],
    "3-5-1-1": [[['POR']],[['DC'],['DC'],['DC','B']],[['E','W'],['M'],['C'],['M'],['E','W']],[['T','A']],[['A','PC']]],
    "4-3-3":   [[['POR']],[['DD'],['DC'],['DC'],['DS']],[['M','C'],['M'],['C']],[['W','A'],['A','PC'],['W','A']]],
    // Corretto: due punte finali coerenti col layout
    "4-3-1-2": [[['POR']],[['DD'],['DC'],['DC'],['DS']],[['M','C'],['M'],['C']],[['T']],[['A','PC'],['A','PC']]],
    "3-4-3":   [[['POR']],[['DC'],['DC'],['DC','B']],[['E'],['M','C'],['C'],['E']],[['W','A'],['A','PC'],['W','A']]],
    // Corretto: due punte finali coerenti col layout
    "3-4-1-2": [[['POR']],[['DC'],['DC'],['DC','B']],[['E'],['M','C'],['C'],['E']],[['T']],[['A','PC'],['A','PC']]],
    "3-4-2-1": [[['POR']],[['DC'],['DC'],['DC','B']],[['E','W'],['M'],['M','C'],['E']],[['T'],['T','A']],[['A','PC']]]
  };
  /* Coordinate specifiche per ogni modulo (x,y in %) per riprodurre disposizione reale.
     Ogni array = linea dall'alto verso il basso. Le sottostringhe devono avere stessa
     struttura di MODULES[module]. Se un modulo manca qui, si usa il layout generico.
     Nota: posizioni facilmente regolabili su richiesta. */
  const MODULE_LAYOUTS = {
    '4-4-2': [
      // GK
      [ {x:50,y:6} ],
      // Difesa a 4
      [ {x:15,y:22},{x:36,y:25},{x:64,y:25},{x:85,y:22} ],
      // Centrocampo a 4 (esterni un po' più alti)
      [ {x:18,y:46},{x:40,y:50},{x:60,y:50},{x:82,y:46} ],
      // 2 punte abbastanza centrali
      [ {x:44,y:75},{x:56,y:75} ]
    ],
    '4-3-3': [
      [ {x:50,y:6} ],
      [ {x:15,y:22},{x:36,y:25},{x:64,y:25},{x:85,y:22} ],
      [ {x:35,y:47},{x:50,y:50},{x:65,y:47} ],
      [ {x:20,y:72},{x:50,y:77},{x:80,y:72} ]
    ],
    '4-2-3-1': [
      [ {x:50,y:6} ],
      [ {x:15,y:22},{x:36,y:25},{x:64,y:25},{x:85,y:22} ],
      [ {x:42,y:43},{x:58,y:43} ],
      [ {x:25,y:58},{x:50,y:60},{x:75,y:58} ],
      [ {x:50,y:78} ]
    ],
    '4-3-1-2': [
      [ {x:50,y:6} ],
      [ {x:15,y:22},{x:36,y:25},{x:64,y:25},{x:85,y:22} ],
      [ {x:35,y:47},{x:50,y:50},{x:65,y:47} ],
      [ {x:50,y:63} ],
      [ {x:46,y:78},{x:54,y:78} ]
    ],
    '3-5-2': [
      [ {x:50,y:6} ],
      [ {x:35,y:26},{x:50,y:23},{x:65,y:26} ],
      [ {x:12,y:48},{x:32,y:51},{x:50,y:53},{x:68,y:51},{x:88,y:48} ],
      [ {x:44,y:76},{x:56,y:76} ]
    ],
    '3-5-1-1': [
      [ {x:50,y:6} ],
      [ {x:35,y:26},{x:50,y:23},{x:65,y:26} ],
      [ {x:12,y:48},{x:32,y:51},{x:50,y:53},{x:68,y:51},{x:88,y:48} ],
      [ {x:50,y:67} ],
      [ {x:50,y:80} ]
    ],
    '3-4-3': [
      [ {x:50,y:6} ],
      [ {x:35,y:26},{x:50,y:23},{x:65,y:26} ],
      [ {x:25,y:50},{x:50,y:53},{x:75,y:50},{x:90,y:48} ],
      [ {x:20,y:73},{x:50,y:77},{x:80,y:73} ]
    ],
    '3-4-1-2': [
      [ {x:50,y:6} ],
      [ {x:35,y:26},{x:50,y:23},{x:65,y:26} ],
      [ {x:25,y:50},{x:50,y:53},{x:75,y:50},{x:90,y:48} ],
      [ {x:50,y:66} ],
      [ {x:46,y:79},{x:54,y:79} ]
    ],
    '3-4-2-1': [
      [ {x:50,y:6} ],
      [ {x:35,y:26},{x:50,y:23},{x:65,y:26} ],
      [ {x:25,y:50},{x:50,y:53},{x:75,y:50},{x:90,y:48} ],
      [ {x:42,y:67},{x:58,y:67} ],
      [ {x:50,y:81} ]
    ],
    '4-4-1-1': [
      [ {x:50,y:6} ],
      [ {x:15,y:22},{x:36,y:25},{x:64,y:25},{x:85,y:22} ],
      [ {x:18,y:46},{x:40,y:50},{x:60,y:50},{x:82,y:46} ],
      [ {x:50,y:66} ],
      [ {x:50,y:80} ]
    ],
    '4-1-4-1': [
      [ {x:50,y:6} ],
      [ {x:15,y:22},{x:36,y:25},{x:64,y:25},{x:85,y:22} ],
      [ {x:50,y:41} ],
      [ {x:18,y:53},{x:40,y:56},{x:60,y:56},{x:82,y:53} ],
      [ {x:50,y:79} ]
    ]
  };
  function changeModule(mod){
    const oldPositions = sandbox.formation.positions || [];
    const oldSlotsFlat = [];
    oldPositions.forEach(line=> line.forEach(slot=> oldSlotsFlat.push(slot)));
    sandbox.formation.module = mod;
    const structure = MODULES[mod];
    const newPositions = structure.map(line=> line.map(roleOptions => ({ roleOptions, main:null, reserves:[] })));
    const used = new Set();
    newPositions.forEach(line=> line.forEach(ns => {
      const idx = oldSlotsFlat.findIndex(os => !used.has(os) && os.main && os.roleOptions.some(r=> ns.roleOptions.includes(r)) );
      if(idx!==-1){ ns.main = oldSlotsFlat[idx].main; ns.reserves = oldSlotsFlat[idx].reserves.slice(0,2); used.add(oldSlotsFlat[idx]); }
    }));
    sandbox.formation.positions = newPositions;
  saveSandbox(sandbox);
    sbModuleSelect.value = mod;
    renderField();
    renderSandboxRoster();
  }

  const sbUserInput = document.getElementById('sandboxUserId');
  const sbSetBtn = document.getElementById('sandboxSetUserBtn');
  const sbExportBtn = document.getElementById('sandboxExportBtn');
  const sbImportBtn = document.getElementById('sandboxImportBtn');
  const sbImportInput = document.getElementById('sandboxImportInput');
  const sbResetBtn = document.getElementById('sandboxResetBtn');
  const sbStatus = document.getElementById('sandboxStatus');
  const sbContent = document.getElementById('sandboxContent');
  const sbModuleSelect = document.getElementById('sbModuleSelect');
  const sbField = document.getElementById('sbField');
  const sbRosterBody = document.getElementById('sbRosterBody');
  const sbCreateAppuntiBtn = document.getElementById('sbCreateAppuntiBtn');
  const sbAppuntiContainer = document.getElementById('sbAppuntiContainer');
  const sbClubSelect = document.getElementById('sbClubSelect');
  const sbClubInfo = document.getElementById('sbClubInfo');

  Object.keys(MODULES).forEach(m => { const o=document.createElement('option'); o.value=m; o.textContent=m; sbModuleSelect.appendChild(o); });
  // Listener selettore modulo rapido (prima mancava: cambiava solo cliccando le card)
  sbModuleSelect.addEventListener('change', () => { if(!sandbox) return; const mod = sbModuleSelect.value; if(mod && MODULES[mod]) { changeModule(mod); announce('Modulo cambiato '+mod); } });

  let sandbox = null;
  function captureClubSnapshotIfNeeded() { if(!sandbox.clubSnapshot) { sandbox.clubSnapshot = { clubId: null, capturedAt: new Date().toISOString(), players: [] }; saveSandbox(sandbox); } }
  function ensureFormationPositions() { const module = sandbox.formation.module; const structure = MODULES[module]; sandbox.formation.positions = structure.map((line, lineIdx) => line.map((roleOptions, posIdx) => { const existing = sandbox.formation.positions?.[lineIdx]?.[posIdx]; if(existing) return existing; return { roleOptions, main:null, reserves:[] }; })); }
  function renderField() {
    sbField.innerHTML='';
    ensureFormationPositions();
    const lines = sandbox.formation.positions;
    const layout = MODULE_LAYOUTS[sandbox.formation.module];
    lines.forEach((line,lineIdx)=> {
      line.forEach((slot,slotIdx)=> {
        // Calcolo coordinate: se layout definito e coerente lo uso, altrimenti fallback generico.
        let x,y;
        if(layout && layout[lineIdx] && layout[lineIdx][slotIdx]) {
          ({x,y} = layout[lineIdx][slotIdx]);
        } else {
          // Fallback generico come prima (distribuzione uniforme)
          const startY = 10, endY = 90;
            const lineCount = lines.length;
            const spacing = lineCount>1 ? (endY-startY)/(lineCount-1) : 0;
            y = startY + spacing*lineIdx;
            function lineXPositions(n){ switch(n){ case 1: return [50]; case 2: return [32,68]; case 3: return [22,50,78]; case 4: return [15,37.5,62.5,85]; case 5: return [10,30,50,70,90]; default:{ const arr=[]; const step=80/(n-1); for(let i=0;i<n;i++) arr.push(10+i*step); return arr; } } }
            const xs = lineXPositions(line.length);
            x = xs[slotIdx];
        }
        const slotWrap = document.createElement('div');
        slotWrap.className='sb-field-slot';
  slotWrap.style.left = x+'%';
  slotWrap.style.top = y+'%';
  slotWrap.dataset.line=lineIdx;
  slotWrap.dataset.x=String(x);
        const circlesDiv = document.createElement('div');
        circlesDiv.className='role-badges';
        slot.roleOptions.forEach(r => { const c=document.createElement('span'); c.className='role-badge '+roleClass(r); c.textContent=r; circlesDiv.appendChild(c); });
        slotWrap.appendChild(circlesDiv);
        const mainBox = document.createElement('div');
        mainBox.className='main-box'+(slot.main?'':' empty');
        if(slot.main){ const pl = data.players.find(p=>p.id===slot.main); mainBox.textContent = pl? pl.name.split(' ')[0]:'?'; }
        else { mainBox.textContent = '+'; }
        mainBox.addEventListener('click',(e)=> openAssignPanel(e,lineIdx, slotIdx, 'main'));
        slotWrap.appendChild(mainBox);
        const reservesDiv = document.createElement('div'); reservesDiv.className='reserves';
        for(let i=0;i<2;i++) {
          const pid = slot.reserves[i]||null;
            const r = document.createElement('div'); r.className='reserve-box'+(pid?'':' empty');
            if(pid){ const pl = data.players.find(p=>p.id===pid); r.textContent = pl? pl.name.split(' ')[0]:'?'; }
            else r.textContent='+';
            r.addEventListener('click',(e)=> openAssignPanel(e,lineIdx, slotIdx, 'res'+i));
            reservesDiv.appendChild(r);
        }
        slotWrap.appendChild(reservesDiv);
        sbField.appendChild(slotWrap);
      });
    });
    // --- Anti-sovrapposizione orizzontale: applica spaziatura minima tra slot nella stessa linea ---
    adjustHorizontalSpacing();
  }
  function adjustHorizontalSpacing(){
    const marginLeft=8, marginRight=92;      // Area utile su asse X (percentuali campo)
    const slotWidth=6;                       // Larghezza stimata pedina (cerchio + label) in % per evitare collisione
    const minGapBase=2;                      // Gap aggiuntivo oltre alla larghezza
    const byLine = new Map();
    sbField.querySelectorAll('.sb-field-slot').forEach(el=> { const l=el.dataset.line; if(!byLine.has(l)) byLine.set(l,[]); byLine.get(l).push(el); });
    byLine.forEach(list => {
      if(list.length<=1){ list[0].style.left = '50%'; return; }
      // Ordine per X pianificata (mantiene la logica del layout)
      list.sort((a,b)=> parseFloat(a.dataset.x)-parseFloat(b.dataset.x));
      const n=list.length;
      // Spazi teorici disponibili
      const usableWidth = marginRight - marginLeft;
      // Gap minimo dinamico: aumenta se ci sono tante pedine
      const minGap = Math.max(minGapBase, (usableWidth - n*slotWidth)/(n-1));
      // Prima assegnazione: mantieni ranking ma distribuisci
      for(let i=0;i<n;i++){
        const target = marginLeft + i*minGap + slotWidth/2 + i*slotWidth; // posizione centro
        list[i].dataset.x = String(target);
      }
      // Se ultimo oltre marginRight, scala tutto
      const lastX = parseFloat(list[n-1].dataset.x);
      const overflow = lastX + slotWidth/2 - marginRight;
      if(overflow>0){
        // comprimi linearmente verso sinistra
        const firstX = parseFloat(list[0].dataset.x);
        const span = lastX - firstX;
        list.forEach(el => {
          const x = parseFloat(el.dataset.x);
          const ratio = span? (x-firstX)/span : 0;
          const newX = x - overflow*ratio - overflow*0.1; // leggera correzione
          el.dataset.x = String(newX);
        });
      }
      // Ultimo passaggio: garantisci separazione
      for(let i=1;i<n;i++){
        const prev = list[i-1]; const cur = list[i];
        let px = parseFloat(prev.dataset.x); let cx = parseFloat(cur.dataset.x);
        const need = slotWidth + minGapBase; // distanza minima finale
        if(cx - px < need){ cx = px + need; cur.dataset.x = String(cx); }
      }
      // Centra il gruppo se avanza spazio
      const first = parseFloat(list[0].dataset.x) - slotWidth/2;
      const last = parseFloat(list[n-1].dataset.x) + slotWidth/2;
      const extra = (marginRight - marginLeft) - (last - first);
      if(extra>2){
        const shift = extra/2;
        list.forEach(el=> { el.dataset.x = String(parseFloat(el.dataset.x)+shift); });
      }
      // Limiti finali
      list.forEach(el=> {
        let x = parseFloat(el.dataset.x);
        if(x < marginLeft + slotWidth/2) x = marginLeft + slotWidth/2;
        if(x > marginRight - slotWidth/2) x = marginRight - slotWidth/2;
        el.style.left = x+'%';
      });
    });
  }
  function getAssignPanel(){ let panel = document.getElementById('sbAssignPanel'); if(!panel){ panel = document.createElement('div'); panel.id='sbAssignPanel'; panel.className='sb-assign-panel'; panel.style.display='none'; panel.innerHTML = `<h4 id='sapTitle'>Assegna</h4><input id='sapSearch' placeholder='Cerca giocatore'><div id='sapSuggestions' class='sap-suggestions'></div><div class='sap-actions'><button id='sapClearBtn' type='button'>Svuota</button><button id='sapCloseBtn' type='button'>Chiudi</button></div>`; sbField.appendChild(panel); panel.querySelector('#sapCloseBtn').addEventListener('click', ()=> closeAssignPanel()); panel.querySelector('#sapClearBtn').addEventListener('click', ()=> { applyAssignment(null); announce('Slot svuotato'); }); panel.querySelector('#sapSearch').addEventListener('input', ()=> renderAssignSuggestions()); } return panel; }
  let currentAssignCtx = null;
  function openAssignPanel(evt,lineIdx,slotIdx,target){ if(!sandbox) return; currentAssignCtx = { lineIdx, slotIdx, target }; const slot = sandbox.formation.positions[lineIdx][slotIdx]; const panel = getAssignPanel(); panel.querySelector('#sapTitle').textContent = 'Slot '+slot.roleOptions.join('/'); const search = panel.querySelector('#sapSearch'); search.value=''; renderAssignSuggestions(); panel.style.display='block'; const fieldRect = sbField.getBoundingClientRect(); const clickX = evt.clientX - fieldRect.left; const clickY = evt.clientY - fieldRect.top; const maxLeft = sbField.clientWidth - panel.offsetWidth - 8; const maxTop = sbField.clientHeight - panel.offsetHeight - 8; panel.style.left = Math.min(clickX, maxLeft) + 'px'; panel.style.top = Math.min(clickY, maxTop) + 'px'; search.focus(); document.addEventListener('click', outsideAssignClick, { capture:true }); }
  function closeAssignPanel(){ const panel = document.getElementById('sbAssignPanel'); if(panel){ panel.style.display='none'; } currentAssignCtx=null; document.removeEventListener('click', outsideAssignClick, { capture:true }); }
  function outsideAssignClick(e){ const panel = document.getElementById('sbAssignPanel'); if(!panel||panel.style.display==='none') return; if(panel.contains(e.target)) return; if(e.target.closest('.sb-field-slot')) return; closeAssignPanel(); }
  function renderAssignSuggestions(){ const panel = getAssignPanel(); if(!currentAssignCtx) return; const sugDiv = panel.querySelector('#sapSuggestions'); const search = panel.querySelector('#sapSearch'); const term = search.value.toLowerCase(); const slot = sandbox.formation.positions[currentAssignCtx.lineIdx][currentAssignCtx.slotIdx]; const allowed = data.players.filter(p => p.roles.some(r=> slot.roleOptions.includes(r)) && (!term || p.name.toLowerCase().includes(term)) ).slice(0,60); sugDiv.innerHTML=''; allowed.forEach(p => { const row = document.createElement('div'); const inSameDiv = playerAssignedInDivision(p.id, currentDivisionId); const origOther = playerOriginalInOtherDivision(p.id, currentDivisionId); const status = inSameDiv? '<span class="status-badge status-red">IN ROSA</span>' : (origOther? '<span class="status-badge status-yellow">ORIG ALT</span>' : ''); row.innerHTML = `<div class='sap-line-top'><span class='sap-line-name'>${p.name}</span>${status}</div><div class='sap-line-meta'>${roleBadgesHTML(p.roles)} Quot: ${p.quote}</div>`; row.addEventListener('click', ()=> { applyAssignment(p.id); announce('Assegnato '+p.name); }); sugDiv.appendChild(row); }); }
  function applyAssignment(playerId){ if(!currentAssignCtx || !sandbox) return; const { lineIdx, slotIdx, target } = currentAssignCtx; const slot = sandbox.formation.positions[lineIdx][slotIdx]; if(!Array.isArray(slot.reserves)) slot.reserves=[]; while(slot.reserves.length<2) slot.reserves.push(null); if(playerId===null){ if(target==='main') slot.main=null; else if(target.startsWith('res')) { const i=Number(target.slice(3)); slot.reserves[i]=null; } } else { sandbox.formation.positions.forEach((line,lI)=> line.forEach((s,sI)=> { if(lI===lineIdx && sI===slotIdx) return; if(s.main===playerId) s.main=null; if(Array.isArray(s.reserves)) s.reserves = s.reserves.map(r=> r===playerId? null : r); })); if(target==='main') slot.main=playerId; else if(target.startsWith('res')) { const i=Number(target.slice(3)); slot.reserves[i]=playerId; } } saveSandbox(sandbox); renderField(); renderSandboxRoster(); closeAssignPanel(); }

  function gatherFormationPlayers(){ if(!sandbox) return []; const ids = new Set(); (sandbox.formation.positions||[]).forEach(line => line.forEach(slot => { if(slot.main) ids.add(slot.main); (slot.reserves||[]).filter(Boolean).forEach(pid=> ids.add(pid)); })); return Array.from(ids); }
  function calcAnnualWageFromQuote(q) { return Math.round(q*0.25*1000)/1000; }
  function renderSandboxRoster() { if(!sandbox) return; const summaryEl = document.getElementById('sbRosterSummary'); const formationIds = new Set(gatherFormationPlayers()); const officialIds = new Set(); let officialClubReleasedHalf = 0; if(sandbox.officialClubId) { const offClub = data.clubs.find(c=>c.id===sandbox.officialClubId); if(offClub) { offClub.roster.filter(r=>r.status==='active').forEach(r=> officialIds.add(r.playerId)); officialClubReleasedHalf = offClub.roster.filter(r=>r.status==='released').reduce((sum,r)=> sum + Math.round(r.wage*0.5*1000)/1000, 0); } } const planIds = new Set(Object.keys(sandbox.rosterPlans||{})); const allIds = new Set([...formationIds, ...officialIds, ...planIds]); let seeded=false; allIds.forEach(pid => { if(!sandbox.rosterPlans[pid]) { const pl = data.players.find(p=>p.id===pid); if(!pl) return; sandbox.rosterPlans[pid] = { years:1, wage: Math.round(pl.quote*0.25*1000)/1000 }; seeded=true; } }); if(seeded) saveSandbox(sandbox); const rowsData = Array.from(allIds).map(pid => { const pl = data.players.find(p=>p.id===pid); let officialEntry=null; if(sandbox.officialClubId) { const offClub = data.clubs.find(c=>c.id===sandbox.officialClubId); officialEntry = offClub?.roster.find(r=>r.playerId===pid && r.status==='active')||null; } const plan = sandbox.rosterPlans[pid]; // Safety recalculation if missing or years changed externally
    if(plan && (!plan.wage || plan._yearsCached !== plan.years)) { const percMap={1:0.25,2:0.50,3:0.75,4:1.0}; plan.wage = Math.round(pl.quote * (percMap[plan.years]||0.25) * 1000)/1000; plan._yearsCached = plan.years; }
    return { pid, pl, officialEntry, plan, inFormation: formationIds.has(pid) }; }).filter(r=>r.pl);
    rowsData.sort((a,b)=> (b.inFormation - a.inFormation) || a.pl.name.localeCompare(b.pl.name));
    sbRosterBody.innerHTML='';
    let totalWage=0; let playerCount=0; const roleCirclesHTML = roles => `<span class='role-badges'>${sortRoles(roles).map(r=>`<span class=\"role-badge ${roleClass(r)}\">${r}</span>`).join('')}</span>`;
    rowsData.forEach(r => { playerCount++; const displayWage = r.officialEntry ? r.officialEntry.wage : (r.plan?.wage ?? Math.round(r.pl.quote*0.25*1000)/1000); totalWage += displayWage; const tr = document.createElement('tr'); if(r.inFormation) tr.style.background='#f0fdf4'; const nameCell = r.inFormation ? `⭐ ${r.pl.name}` : r.pl.name; tr.innerHTML = `<td style='padding:4px;'>${nameCell}</td>`+ `<td style='padding:4px;'>${roleCirclesHTML(r.pl.roles)}</td>`+ `<td style='padding:4px; text-align:right;' class='wage-cell'>${wageCellHTML(displayWage)}</td>`+ `<td style='padding:4px; text-align:center;'><input type='number' min='1' max='4' data-sb-years='${r.pid}' value='${r.plan.years}' style='width:42px;'></td>`+ `<td style='padding:4px; text-align:center;'>`+ (r.inFormation?`<button data-sb-remform='${r.pid}' title='Rimuovi dalla formazione' style='font-size:10px;'>Frm</button>`:'')+ `<button data-sb-removeall='${r.pid}' title='Rimuovi da sandbox (anche formazione)' style='font-size:10px; margin-left:4px;'>Del</button>`+ `</td>`; sbRosterBody.appendChild(tr); });
    totalWage += officialClubReleasedHalf; totalWage = Math.round(totalWage*1000)/1000; summaryEl.textContent = `Giocatori sandbox: ${playerCount}/30 | Stipendi sandbox: ${totalWage}/110`; applyWageIntensity(sbRosterBody); }

  sbRosterBody.addEventListener('input', e => { const pid = e.target.dataset.sbYears; if(!pid||!sandbox) return; let years = Number(e.target.value)||1; if(years<1) years=1; if(years>4) years=4; e.target.value=years; const pl = data.players.find(p=>p.id===pid); if(!pl) return; sandbox.rosterPlans[pid] = sandbox.rosterPlans[pid] || { years:1, wage:0 }; sandbox.rosterPlans[pid].years = years; const perc = {1:0.25,2:0.50,3:0.75,4:1.0}[years]; sandbox.rosterPlans[pid].wage = Math.round(pl.quote * perc * 1000)/1000; saveSandbox(sandbox); renderSandboxRoster(); announce('Durata aggiornata'); });
  sbRosterBody.addEventListener('click', e => { const remForm = e.target.dataset.sbRemform; const remAll = e.target.dataset.sbRemoveall; if(!sandbox) return; if(remForm) { sandbox.formation.positions.forEach(line=> line.forEach(slot => { if(slot.main===remForm) slot.main=null; slot.reserves = slot.reserves.map(r=> r===remForm?null:r); })); saveSandbox(sandbox); renderField(); renderSandboxRoster(); announce('Rimosso dalla formazione'); return; } if(remAll) { sandbox.formation.positions.forEach(line=> line.forEach(slot => { if(slot.main===remAll) slot.main=null; slot.reserves = slot.reserves.map(r=> r===remAll?null:r); })); delete sandbox.rosterPlans[remAll]; saveSandbox(sandbox); renderField(); renderSandboxRoster(); announce('Giocatore rimosso'); return; } });

  function renderAppunti() { sbAppuntiContainer.innerHTML=''; sandbox.appuntiSets.forEach(set => { const wrap = document.createElement('div'); wrap.style.border='1px solid #d1d5db'; wrap.style.borderRadius='8px'; wrap.style.padding='10px'; wrap.style.background='#fff'; const header = document.createElement('div'); header.style.display='flex'; header.style.justifyContent='space-between'; header.style.alignItems='center'; header.innerHTML = `<strong>${set.name}</strong><button data-sb-delset='${set.id}' style='font-size:11px;'>Elimina</button>`; wrap.appendChild(header); const colsMeta = [ ['top','Top player'], ['seconda','Seconda fascia'], ['terza','Terza fascia'], ['titolari','Titolari'], ['scommesse','Scommesse/Giovani'] ]; const colsRow = document.createElement('div'); colsRow.style.display='flex'; colsRow.style.gap='10px'; colsRow.style.flexWrap='wrap'; colsMeta.forEach(([key,label]) => { const colDiv = document.createElement('div'); colDiv.style.flex='1 1 180px'; colDiv.style.minWidth='160px'; colDiv.style.background='#f8fafc'; colDiv.style.padding='6px'; colDiv.style.borderRadius='6px'; colDiv.innerHTML = `<div style='font-weight:600; font-size:12px; margin-bottom:4px;'>${label}</div>`; const searchWrap = document.createElement('div'); searchWrap.style.position='relative'; searchWrap.style.marginBottom='4px'; const inp = document.createElement('input'); inp.placeholder='Aggiungi'; inp.style.width='100%'; inp.style.fontSize='11px'; inp.dataset.col=key; inp.dataset.set=set.id; const sug = document.createElement('div'); sug.className='suggestions'; sug.style.top='24px'; sug.style.maxHeight='180px'; sug.style.overflowY='auto'; searchWrap.appendChild(inp); searchWrap.appendChild(sug); colDiv.appendChild(searchWrap); const list = document.createElement('div'); list.dataset.list = key; list.dataset.set=set.id; list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='4px'; (set.columns[key]||[]).forEach(pid => { list.appendChild(renderAppuntiPlayerBadge(pid, set.id, key)); }); colDiv.appendChild(list); colsRow.appendChild(colDiv); inp.addEventListener('input', ()=> refreshAppuntiSuggestions(inp, sug, set.id, key)); document.addEventListener('click', ev => { if(!sug.contains(ev.target) && ev.target!==inp) sug.innerHTML=''; }); }); wrap.appendChild(colsRow); sbAppuntiContainer.appendChild(wrap); }); }
  function renderAppuntiPlayerBadge(playerId, setId, colKey) { const badge = document.createElement('div'); badge.style.padding='2px 4px'; badge.style.fontSize='11px'; badge.style.borderRadius='4px'; badge.style.background='#fff'; badge.style.border='1px solid #cbd5e1'; badge.style.display='flex'; badge.style.justifyContent='space-between'; badge.style.alignItems='center'; badge.style.gap='6px'; const player = data.players.find(p=>p.id===playerId); if(player){ const wrapLeft = document.createElement('div'); wrapLeft.style.display='flex'; wrapLeft.style.flexDirection='column'; wrapLeft.style.lineHeight='1.1'; const nameSpan = document.createElement('span'); nameSpan.textContent = player.name; nameSpan.style.fontWeight='600'; const metaSpan = document.createElement('span'); metaSpan.style.fontSize='10px'; metaSpan.style.opacity='0.8'; metaSpan.innerHTML = roleBadgesHTML(player.roles) + ` q:${player.quote}`; wrapLeft.appendChild(nameSpan); wrapLeft.appendChild(metaSpan); badge.appendChild(wrapLeft); } else { badge.textContent='(?)'; } const statusColor = computePlayerStatusColor(playerId); if(statusColor) badge.style.background=statusColor; const removeBtn = document.createElement('button'); removeBtn.textContent='x'; removeBtn.style.fontSize='10px'; removeBtn.style.marginLeft='6px'; removeBtn.dataset.sbpRemove=`${setId}|${colKey}|${playerId}`; badge.appendChild(removeBtn); return badge; }
  function computePlayerStatusColor(playerId) { if(!sandbox || !sandbox.officialClubId) return ''; const myClub = data.clubs.find(c=>c.id===sandbox.officialClubId); if(!myClub) return ''; const myDivisionId = myClub.divisionId; if(myClub.roster.some(r=> r.playerId===playerId && r.status==='active')) return '#86efac'; const otherSameDiv = data.clubs.find(c=> c.id!==myClub.id && c.divisionId===myDivisionId && c.roster.some(r=> r.playerId===playerId && r.status==='active')); if(otherSameDiv) return '#fecaca'; const originalOtherDiv = data.clubs.some(c=> c.divisionId!==myDivisionId && c.roster.some(r=> r.playerId===playerId && r.status==='active' && r.original)); if(originalOtherDiv) return '#fde68a'; return ''; }
  function refreshAppuntiSuggestions(inputEl, sugEl, setId, colKey) { const term = inputEl.value.toLowerCase(); sugEl.innerHTML=''; if(!term) return; const list = data.players.filter(p=> p.name.toLowerCase().includes(term)).slice(0,20); list.forEach(p => { const div = document.createElement('div'); div.innerHTML = `<div style="font-weight:600;">${p.name}</div><div style="font-size:10px;opacity:.8;">${roleBadgesHTML(p.roles)} q:${p.quote}</div>`; div.addEventListener('click', ()=> { const set = sandbox.appuntiSets.find(s=>s.id===setId); if(!set) return; set.columns[colKey] = set.columns[colKey]||[]; if(!set.columns[colKey].includes(p.id)) set.columns[colKey].push(p.id); saveSandbox(sandbox); renderAppunti(); announce('Aggiunto '+p.name+' a '+colKey); }); sugEl.appendChild(div); }); }
  sbAppuntiContainer.addEventListener('click', async e => { const rm = e.target.dataset.sbpRemove; if(rm) { const [setId,colKey,pid] = rm.split('|'); const set = sandbox.appuntiSets.find(s=>s.id===setId); if(set){ set.columns[colKey] = (set.columns[colKey]||[]).filter(id=>id!==pid); saveSandbox(sandbox); renderAppunti(); announce('Rimosso da appunti'); } } const delSet = e.target.dataset.sbDelset; if(delSet){ if(await uiConfirm('Eliminare appunti?')) { sandbox.appuntiSets = sandbox.appuntiSets.filter(s=>s.id!==delSet); saveSandbox(sandbox); renderAppunti(); announce('Set appunti eliminato'); } } });
  sbCreateAppuntiBtn.addEventListener('click', async () => { if(!sandbox) return; const name = await uiPrompt('Nome appunti',{ title:'Nuovo set appunti', placeholder:'es. Target difesa'}); if(!name) return; sandbox.appuntiSets.push({ id:'app_'+Math.random().toString(36).slice(2,9), name, columns:{ top:[], seconda:[], terza:[], titolari:[], scommesse:[] } }); saveSandbox(sandbox); renderAppunti(); announce('Set appunti creato'); });

  function refreshSandboxUI() { if(!sandbox) { sbContent.style.display='none'; sbExportBtn.disabled=true; sbImportBtn.disabled=true; sbResetBtn.disabled=true; return; } sbContent.style.display='block'; sbExportBtn.disabled=false; sbImportBtn.disabled=false; sbResetBtn.disabled=false; sbModuleSelect.value = sandbox.formation?.module||'4-4-2'; ensureFormationPositions(); renderField(); renderSandboxRoster(); renderAppunti(); sbStatus.textContent = `Ultimo salvataggio: ${new Date(sandbox.updatedAt||sandbox.createdAt).toLocaleTimeString()}`; populateClubSelectForSandbox(); refreshOfficialClubInfo(); }
  function ensureSandbox(){ const uid = sbUserInput.value.trim(); if(!uid){ return uiAlert('Inserisci un identificativo'); } setCurrentSandboxUserId(uid); sandbox = loadSandbox(uid); if(!sandbox.formation || !sandbox.formation.module) { sandbox.formation = sandbox.formation || { module:'4-4-2', positions:[] }; sandbox.formation.module = sandbox.formation.module || '4-4-2'; } if(!sandbox.officialClubId) sandbox.officialClubId=null; saveSandbox(sandbox); refreshSandboxUI(); announce('Sandbox pronta'); }
  const storedUid = getCurrentSandboxUserId(); if(storedUid){ sbUserInput.value=storedUid; sandbox = loadSandbox(storedUid); if(sandbox){ if(!sandbox.formation) sandbox.formation={ module:'4-4-2', positions:[] }; if(!sandbox.formation.module) sandbox.formation.module='4-4-2'; saveSandbox(sandbox); refreshSandboxUI(); refreshOfficialClubInfo(); } }
  sbSetBtn.addEventListener('click', ensureSandbox);
  sbExportBtn.addEventListener('click', ()=> { if(sandbox) { exportSandbox(sandbox); announce('Sandbox esportata'); } });
  sbImportBtn.addEventListener('click', ()=> { if(!sandbox) return; sbImportInput.click(); });
  sbImportInput.addEventListener('change', e=> { const f=e.target.files[0]; if(!f||!sandbox) return; importSandbox(f, sandbox.userId).then(sb=>{ sandbox=sb; refreshSandboxUI(); announce('Sandbox importata'); }).catch(err=> uiAlert('Import fallito: '+err.message)); });
  sbResetBtn.addEventListener('click', async ()=> { if(!sandbox) return; if(!(await uiConfirm('Reset sandbox?'))) return; sandbox = resetSandbox(sandbox.userId); refreshSandboxUI(); announce('Sandbox resettata'); });
  function populateClubSelectForSandbox(){ if(!sbClubSelect) return; const current = sandbox?.officialClubId || ''; sbClubSelect.innerHTML = '<option value="">--</option>' + data.clubs.map(c=>`<option value="${c.id}" ${c.id===current?'selected':''}>${c.name}</option>`).join(''); }
  function refreshOfficialClubInfo(){ if(!sandbox || !sandbox.officialClubId){ sbClubInfo.style.display='none'; return; } const club = data.clubs.find(c=>c.id===sandbox.officialClubId); if(!club){ sbClubInfo.style.display='none'; return; } sbClubInfo.style.display='block'; const active = club.roster.filter(r=>r.status==='active'); sbClubInfo.innerHTML = `<strong>${club.name}</strong><br>`+ `Rosa: ${active.length}/30 | Stipendi: ${club.wageTotal}/110 | Budget: ${club.budget}<br>`+ `Ultima transazione: ${club.transactions?.slice(-1)[0]?.description||'-'}`; }
  sbClubSelect?.addEventListener('change', () => { if(!sandbox) return; sandbox.officialClubId = sbClubSelect.value||null; saveSandbox(sandbox); refreshOfficialClubInfo(); renderAppunti(); announce('Club ufficiale aggiornato'); });
})();
</script>
</body>
</html>
